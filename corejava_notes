


 
    java:
	
	
	 ->programming languages
	 
	     pop
		 oop
		 mop
		 sop
		 ...
		 
	 
	 ->to make the software/application
	 
	 ->object oriented programming language
	 
	 ->using java what applications we can develop?
	 
	 
	 
	  we have two types of applciations
	  
	  
	    ->standalone applications/desktop applications -results are not sharable
		->distributed applications-results are sharable across the globe
		gmail.com
		facebook.com etc..
		
		
	 
	 jamesgosling -> in three editions
	 
	  jse->java standard edition --> standalone applications
	  jee->java enterprise edition -> distributed applications & standalone apps
	  jme->java micro/mobile edition -> 
	 
	 
if any requirement -> 

   program -> set of instructions

every programmer must follow some rules/syntaxes -> 

     
java -> sunmicrosystem 
     -> oracle 

	 
	 <datatype> <variablename>=<value>;
	 
	 

for java program, there is basic structure

 
  every java program must starts with by defining a class.
  
  
  without defining a class there is no java program .
  
  
  syntax:
     
	   class <classname>
	   {   
	      
	      public static void main(String[] args)
		  {
		    //logic
		  }
		  
	   }

note: java is case senstive programming language.

note: every java reserved keyword must be in lowercase.

note: without defining the main(), we can compile the program, but we can't run 
      the program because execution of java program should starts from main().
	  
	  

  i want to write the java program?
  
    prerequisites to write the java program?
	
	1.download the java software(jdk)->open source
	
	2.install this software
	
	3.select the editor(notepad,notepad++,eclipse,netbeans,intellij)
	
	4.write the java program 
	
    5.save the java program (<filename>.java)
	
	6.compile the java program (javac <filename>.java)
	
	7.run the java program (java <classname>)
	
	
why should we go for compiling the java program?

  java compiler will check for all the syntaxes
  
  java compiler -> compiletime error
  
  java compiler -> will generate .class file
  
  .java file contains source code
  .class file contains byte code
  
  byte code:
  
    byte code can not be understandable by human 
  
    byte code can be understandable by jvm(java interpretor)
	
	  jvm -> byte code and converts it into machine level code 
	  
	  
java compiler -> compiles the program (Checking the syntaxes)
java interpretor(jvm) -> executes the program (converting bytecode to machine level code)

 
in java, to display any information in the console one statement we have to use?

    System.out.println("welcome to java"); 
    

to compile 
   
    javac Welcome.java

to execute

     java <classname>
	 java Infosys
	 
	 
open the command prompt


in real world , we never use these basic editors to develop the programs

ide's ->integrated development environment


 eclipse
 myeclipse
 intellij
 netbeans
 bluej
 visualstudio
 ...
 
how to download and install the eclipse in your mahines?

note:
the code which we are writing in the ide is autocompiled


   jdk vs jre vs jvm
   
   
java development kit

   it provides two environments
   
         -dev environment(develop the java programs)
		 -runtime environment(execute the java programs)
		 
		 
jre:
   java runtime environment

      ->runtime environment (only we are able to execute the java applications)
	  
	  
jvm:
   java virtual machine

   
	 ->using this we can develop the actual java program
	 
	 
	 
'every java program should starts with by defining class 

  class <classname>
  {
   //variables

   //methods

  }   
	 
	 
variable:
``````````
variable is used to store the data

  it is a name which we are giving to memory location .

syntax:
  
   <datatypename> <variablename> = <value>;

  int x=100;  

  int 100=100;-invalid

  int int =100;//invalid

  int _xyz=100;

  int x123 =100;

  int 123x=100;

  int $xyz=123;

  int xyz*123=100;  
	 
	 
A variable name can consist of Capital letters A-Z, lowercase letters a-z digits 0-9, and two special characters such as _ underscore and $ dollar sign.

The first character must not be a digit.

Blank spaces cannot be used in variable names.

Java keywords cannot be used as variable names.

Variable names are case-sensitive.

There is no limit on the length of a variable name but by convention, it should be between 4 to 15 chars.

Variable names always should exist on the left-hand side of assignment operators.	 

example:
`````````


public class Welcome {
	
	public static void main(String[] args) {
		
		int x=100;
		//int int =100;
		int _xyz=123;
		
		int $xyz=123;
		byte b1 = 127;
		
		float f = 12.3467676f;
		double d = 56.6776565656556656;
		char c = 'a';//2 bytes
		boolean b =true;
		
		//int xyz abc = 123;
		//int xyz*123=12;
		//int 1xyz=123;
		
	}

}






Primitive Data Type: In Java, the primitive data types are the predefined data types of Java. They specify the size and type of any standard values. Java has 8 primitive data types namely byte, short, int, long, float, double, char and boolean.


datatypes in java:

   4 types 
   
    integer 
	   byte
	   short
	   int
	   long
	   
	float 
	   float
	   double
	   
	charcter
	   char
	   
	boolean 
	   boolean (true/false)
	   
	
based on the value and the range will decide a specific datatype

every datatype is having 
 their own memory size and range 
 
  
  int x = 100;(4 bytes)
  
  
byte datatype -> 1 byte -> 8 bits


 -2^n-1 to 2^n-1 -1
 
 -2^7 to 2^7 -1
 
 -128 to 127
 
  byte b = 130;
  
 
usually float datatypes we are using to store decimal values
by default decimal data can be considerd as double type 

 
float f = 23.45f;
	 
	 
	 
method:
````````
method is the place where we are writing the logic to perform some operations 
based on the requirement.



syntax:

  
     [accessmodifier] <returntype> <methodname>([paramters if any])
	 {
	 
	     //logic
	 }


ex:
     public void sum(int x, int y)
	 {
	   System.out.println("sum is: " +(x+y));
	 }
	 

note:
if a method is not returning any value , we have to specify returntype as 
void


 int getSalary()
{
  return 50000;
}


note:
return value and retuntype must be compatible otherwise we will get 
compiletme error.


System.out.println(getSalary());
//output as 50000



int getSum(int x, int y)
{
  return x+y;
}

   getSum(4,5);

Hungarian notation /camelcase notation:

recommendation:
 
 getAge()
 getStudentInfo()
 getSalary()
 getThreadStatus()
 setMarks();
 
example:
`````````

public class Demo {
	
	
	static byte b=100;
	public static void display()
	{
		System.out.println("byte value is " + b);
	}
	
	public static void main(String[] args) {
		//calling the method
		display();
		
	}

}

example:
`````````

public class Demo {
	
	
	
	public static int getSum(int x, int y)
	{
		return x+y;
	}
	
	public static void main(String[] args) {
		int result = getSum(120,345);
		
		System.out.println("sum is : " + result);
		
	}

}



instance vs static:
```````````````````


     why java is oop language?
	 
	 answer: since it follows oops principles.
	 
	 oops principles: 
	  
	   we have 4 oops principles
	   
	 who derived these oops principles?

          omg(object management group)
          candian organization 
		  
	     
		  
java is one of the object oriented programming language.
.net,python,php..


  inheritance
  polymorphism
  abstraction 
  encapsulation 
  
  
 in java, how can we achieve these principles?

  we have two concepts

  1.class
  2.object

  
 object: 
  
  note:
  
  when we define a class, memory spaces will not be allocated
  for datamembers.
  
  we should go for creating the object
  
  
  for a single class, how many object(s) we can create?
  
   as many as we want based on the requirement.
   
   in a college, 
      -> 1000 students
	  
Student anita = new Student();	  
  
  
object:
```````` 
  instance of a class is known as object.
  
  instance: allocating sufficient amount of memory space for the non-static
            data members which we are declaring inside the class.
			
			
syntax:
```````
   <classname> <objectname> = new <classname>();
   Student anita = new Student();

   new -> dynamic memory allocation operator
   
example:
`````````

public class Demo {
	
	int x=200;
	public void display()
	{
		System.out.println("integer value is : " + x);
	}

	public static void main(String[] args) {
		
		
		//creating the object
		
		
		Demo obj = new Demo();
		
		System.out.println("integer value is : " + obj.x);
		
		obj.display();
		
		
	}

}

note:
````
using . operator we are able to access class level datamembers.

   
  
  
  
 instance vs static:

instance  -> non static 
static -> static


 int x;
 static int x;
 
 
note:
to make any property as staic we should add static keyword before method or variable
declaration.

 public void m1()
 {
  //instance area 
 }
 
 public static void m2()
 {
   //static area
 }
  
  
  the area which belongs to non-static /instance method is known as 
  instance area
  
  the area which belongs to static method is known as static area
  
  
note:
`````
for non static/instance properties memory will be created whenever we create
the object.


note:
`````
from static area to access instance properties using object name it is possible.
from static area to access static properties we have threee possibilities

   1.using class name
   2.diretly we can access
   3.using object name(it is not recommended)
  
if you define any property as static, memory will be created only once 
at the class loading time before object creation.


note:
from the instance area , we can access instance properties directly 
and as well as staic proeprties using class name or directly.



example:
```````

public class Student {
	//instance properties
	int stid=100;
	String stname="Ram";
	
	//static property
	static String collegeName="cbit";
	
	//instance method
	public void display()
	{
		//instance area
		System.out.println("student id: " + stid);
		System.out.println("student name: " + stname);
		System.out.println("student collegename: " + collegeName);
		
	}
	
	
	public static void main(String[] args) {
		//static area
		Student st1 = new Student();
		System.out.println("student id: " + st1.stid);
		System.out.println("student name: " + st1.stname);
		System.out.println("college name: " +collegeName);
		System.out.println("===================");
		
		st1.display();
		
		
	}

}


public static void main(String[] abc)
{
}

why main() method is taking array of String as an argument?

 -> to deal with command line arguments
 
 command line arguments:
 
 these are the arguments which we are passing from the command line while 
 we are executing the java program.
 
 
 
 java Test1 rama infosys
 ramainfosys
 
 
 

when we execute the java program , jvm internally invokes main() 


we have 8 datatypes


Wrapper classes

 are available in java.lang package
 
 
short -> Short -> parseShort(String s)->short
byte  ->Byte
int
long 

float
double
char
boolean


example:
````````

public class Test1 {
	
	public static void main(String[] args) {
	System.out.println("sum is : " + (Integer.parseInt(args[0])+Integer.parseInt(args[1])));
		
	}

}


constructor:
`````````````

constructor is a special member method 
which must be similar to class name.


->constructor should not return any thing even void also.
->constructor name must be similar to class name.


purpose:
to initialize the object
  ->assign the values to the datamembers of the class.
  
  
example without constructor:
````````````````````````````

public class Test1 {
	//class level variables
	int x, y;
	
	public void assign(int p,int q)
	{
		x=p;
		y=q;
	}
	
	public void sum()
	{
		System.out.println("sum is: " + (x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.assign(10,20);
		obj.sum();
		
	}

}

note:
whenever we create the object corresponding constructor will be invoked.


with constructor:
`````````````````

public class Test1 {
	//class level variables
	int x, y;
	
	public  Test1()
	{
		x=100;
		y=200;
	}
	
	
	public void sum()
	{
		System.out.println("sum is: " + (x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.sum();
		
	}

}


types of constructors:
````````````````````````

-default constructor->constructor without paraeters
-parameterized constructor


when we don't have any constructor inside a program 
then java compiler will generate one constructor 
i.e system defined default constructor
 -> to assign the default values
 
 user defined default constructor -> to assign our own values.
 
 
 
 
 note:
 
 java compiler will generate system defined default constructor if 
 program has no constructor(s) or if it has user defined constructor .
 
 
 note:
 java compiler will not generate this system defined default constructor 
 if program has parameterized constructor.
 
  default constructor is available in only one form 
  where as parameterized constructor is available in many forms.
  
  
 example:
 ````````
 
public class Test1 {
	// class level variables
	int x, y;

	//parameterized constructor
	public Test1(int p, int q) {
		x=p;
		y=q;
	}

	public void sum() {
		System.out.println("sum is: " + (x + y));
	}

	public static void main(String[] args) {

		Test1 obj = new Test1(10,20);

		obj.sum();

	}

}


this:
this is the java reserved keyword which is used in following 
two purposes.

1. if class level variables and constructor level parameters are same 
to differentiate we have to use this for the class level variables.

2.to call current class constrcutor from any other constructor of a class.

  this() -> it will call current class default constructor
  this(..) -> it will call current class parametrized constructor
  
  
note:
constructor call must be always first executable statement inside a constructor.


conditional statements:
````````````````````````
Conditional statements define conditions that are true or false and then execute based on whether or not the condition is true

java if statement is used to test the condition 
it checks boolean condition true or false.


  -if statement
  -if else statement
  -if else if ladder
  -nested if statement


syntax

if(condition)
{
 //code to be executed
}

syntax:

 if(condition)
 {
   //code to be executed
  }
  else
  {
  //code to be executed
  }
  
 

example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=17;
		//check if the number is divisible by 2 or not
		
		if(number%2==0) {
			System.out.println("even number");
			
		}
		else
		{
			System.out.println("odd number");
		}
		
		
	
		
		
	}
	
	
}


assigment:
`````````
check if the given year is leap year or not using 
if else?


  
 ternary operator:
 `````````````````
 we can also use ternary operator(?:) to perform the task of if..else statement.
 
 it is a shorthand way to check the condition.
 
 
 if the condition is true the result of ? will be retunred
 if the condition is false the result of : will be returned.
 
 
example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=18;
		//check if the number is divisible by 2 or not
		
		String result =(number%2==0)?"even number":"odd number";
		
	  System.out.println(result);
		
		
	}

}

if-else-if ladder statement:
`````````````````````````````
it executes one condition from multiple statements.

syntax:
 if(condition1)
 {
   //code to be executed
 }
 else if(condition2)
 {
   //code to be executed if condition2 is true
 }
 else if(condition3)
 {
   //code to be executed if condition3 is true
 }
 ..
 else
 {
   //code to be executed if all conditions are false.
 }
 
assignment:
````````````
write a program of grading system based on student marks
using if-else-if ladder statement.


assignment:
write a program to check positive,negative or zero?


nested if statement:
`````````````````````
if{

  if{
  }
 }
 
example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int age=15;
		int weight=48;
		//applying condition
		if(age>=18)
		{
			if(weight>50)
			{
				System.out.println("you are eligible to donate blood");
			}
			else
			{
				System.out.println("you are not eligible to donate blood");
			}
		}
		
		else
		{
			System.out.println("age must be greater than 18");
		}
		
	}
	
	
}

switch statement:
``````````````````
switch statement executes one statement from multiple conditions.

switch statement works with byte,short,int ,long,String,enum and some 
wrapper types.

syntax:

 switch(expression)
 {
 
 case value1:
 //code to be executed;
 break;//optional
 case value2:
 //code to be executed;
 break;
 ...
 
 ...
 default:
 //code to be executed if all cases not matched
 
 }
  


assignment
````````````
finding month name for the given number?

example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		
		int number=17;
		String month="";
		//switch statement
		switch(number) {
		
		//case statements with in the switch blokc
		
		case 1: month="january";
		break;
		case 2: month="February";
		break;
		case 3: month="March";
		break;
		case 4: month="April";
		break;
		case 5: month="May";
		break;
		case 6: month="June";
		break;
		case 7: month="July";
		break;
		case 8: month="August";
		break;
		case 9: month="September";
		break;
		case 10: month="October";
		break;
		case 11: month="November";
		break;
		case 12: month="December";
		break;
		
		default: System.out.println("invalid month");
		
		
		
		}
		
		System.out.println(month);
	}
	
}

assignment:
````````````
program to check vowel or consonant?


switch case with enum type:
```````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		Day[] DayNow = Day.values();
		
		for(Day Now: DayNow)
		{
			switch(Now)
			{
			case Sun:
				System.out.println("sunday");
				break;
			case Mon:
				System.out.println("monday");
				break;	
			}
		}
		
		
	}
}


loops:
``````

if we want to execute the portion of code repeatedly based on the condition 

 in java, how many loops we have?
 
  for loop
  while loop
  do while loop
  enhanced for loop(for each loop)
  

for loop is used to iterate a part of the program several times.
if the number of iteration is fixed,it is recommended to use for loop.


inside for loop 

 we have to initialize the variable
 we have to check the condition 
 we have to increment/decrement the value.
 
 syntax:
 
  for(initialization;conditionchecking;increment/decrement)
  {
    //statement 
  }
  
example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		for(int i=1;i<=5;i++) {
		  System.out.println("welcome to java session");
		}
	}
}



nested for loop:
```````````````

public class Test1 {
	
	
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=3;i++) {
	
			//loop of j
			for(int j=1;j<=3;j++)
			{
				
				System.out.println(i + " " +j);
			}
			
			
		}
	}
}


pattern matchig example using nested for loop:
`````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=5;i++) {
	
			//loop of j
			for(int j=1;j<=i;j++)
			{
				
				System.out.print("*");
			}
			System.out.println();
			
			
		}
	}
}


while loop:
```````````
it is used to iterate a part of the program repeatedly until 
the specified condition is true
as soon as the boolean condition is false, the loop automatically stops.

if the number of iteration is not fixed, it is recommended to use
while loop.

example:
```````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}
}


display the first 10 numbers in reverse order using while loop?


public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}
}


displaying the even numbers using while loop in reverse order:
```````````````````````````````````````````````````````````````

public class Test1 {
	
	
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			if(i%2==0)
				System.out.println(i);
			i--;
		}
	}
}

do while:
`````````
 atm machines
 
 ->enter password:
 
 java do while loop is called an exit control loop
 therfore unlike while and for loop 
 the do while loop check the condition at the end of  the loop body.
 

 It is executed atleast once because condition is checked 
 after loop body.

		syntax:
			do{
			  //code to be executed or loop body
			 }
			 while(condition);


		example:
		````````

		public class Test1 {
			
			public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
			 
			public static void main(String[] args) {
				
				int i=1;
				do {
					System.out.println(i);
					i++;
				} while (i>=10);
			}
		}



operators:
```````````
operator in java is a symbol that is used to perform 
operations

there are many types of operators in java
 
-unary operators
-arithmetic operators
-shift operator
-relational operator
-bitwise operator
-logical operator
-ternary operator
-assignment operator

  
 example on unary operator:
 
 
 
public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int x=10;
		System.out.println(x++);//10
		System.out.println(++x);//12
		System.out.println(x--);//12
		System.out.println(--x);//10
	}
}

example:
`````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=10;
		int b=10;
		
	System.out.println(a++ + ++a);//10+12->22
	System.out.println(b++ + b++);//10+11->21
	}
}


~ and !
 
a=10
~a ->

example:
````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=10;
		boolean b= true;
		System.out.println(!b);//false
		System.out.println(~a);//-11
	}
}


example on bitwise operators:
``````````````````````````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=12,b=10;
		/*
		 * 01100 
		 * 01010 
		 * 00110 
		 * 16 8 4 2 1
		 */
		System.out.println(a&b);//8
		System.out.println(a|b);//14
		System.out.println(a^b);//6
		
		System.out.println(a<<3);
		//formula -> 2^n * a-> 2^3 * 12 =>96
		
		System.out.println(a>>2);
		//formular -> a/2^n -> 12/4 -> 3
		
	}
}





packages:
`````````
definition:
 package is a collection of classes, interfaces and sub packages
 
 
purpose:
````````
  ->reusability
  ->avoids naming conflicts
  

syntax:
```````
  package <packagename>;
  
  
naming convention:
```````````````````
<reverseof your companywebsite>.<projectname>.<modulename>;

package names are always must be in lower case.

ex:

->com.infosys.jse.packages;


  com.infosys.banking.withdrawl
  
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip


  examples:
  package p1;
//business logic class
public class Test1 {
	
	 public void sum(int x, int y)
	 {
		 System.out.println("sum is : " + (x+y));
	 }

}


Test2.java:
````````````
package p1;
//execution logic class
public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}
	
}


Test3.java:
````````````
package p2;
import p1.Test1;
public class Test3 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 2);
	}

}


we have two types of package(S)
 
 1.pre defined package(S)
 2.user defined package(s)
 

java.util package

 ArrayList al = new ArrayList();
 
 
note:
default imported package for every java application is java.lang 


example:
`````````
package p2;

import java.util.ArrayList;

public class Test4 {
	
	public static void main(String[] args) {
		
		
		ArrayList al = new ArrayList();
		
		String s = new String("Ram");
		
	}

}




access modifiers:
```````````````````

 we have 4 access modifiers
 
  private 
  default
  protected
  public 
  

int x;

it controls the visibility of the properties over the pacakge(s).


ccesmodifiers:
````````````````

it is used to control the scope of the visibility over the package(s).


  private 
  default(not a keyword)
  protected
  public
  
  
 private properties we can access only with in class 
 not able to access 
  same package subclass/non-subclass
  other package subclass/non-subclass

 default properties we can access 
  with in the class
  same pacakge subclass/subclass but not from 
  other package subclass/non-subclass

 protected properties we can access 
  with in the class 
  same pacakge subclass/non-subclass
  other package sub class but not from 
  other package non-subclass
 
when it comes to public from any where we can access there is no 
restriction.

 
pakage p1;
class Test1{}

pacakge p1.p2;
class Test2{}


 
 java.lang
 java.lang.reflect
 
 
 package p3;
 import p1.*;
 import p1.p2.*;
 class Test3
 {
 
 }
 
 
->by importing the main package only we are able to access main package 
proeprties 

->if we want to reuse sub package properties explictly we have to import 
sub pacakge.


 
 
 oops principles:
 ```````````````
 omg(object management group)
 

inheritance:
`````````````
  it is the process of taking the properties from one class to another 
  class.
  
  the class which is giving the properties is known as base/super/parent 
  class.
  
  the class which is taking the properties is known as sub/derived/child
  class.
  
  note:
  `````
  using extends keyword we can achieve the concept of inheritance.
  in the context of child class only we have to use extends keyword.
  
  types of inheritances:
  
   simple/single inheritance
   multilevel inheritance
    multiple inheritance
   hierarchical inheritance
   hybrid inheritance
   
   
   E
   
   D
  
  A B C
  
   
   class A 
   {}
   class B extends A{}
   class C extends A,B{}
   
  
 note:

using extends keyword we are able to derive single class from single class 
not from multiple classes or more than one class.

 
->reusability


note:
````
if we create the child class object, memory locations will be created for 
both parent class properties and child class properties where as 
if we create the object for parent class object, only we are able to access
parent class properties.


is-a relation 
``````````````
whenever one class inherits another class,it is called as 
an IS-A relationship.

HAS-A relation:
`````````````````
whenever an instance of one class is used in another class, it is called
HAS-A relationship.

  class Student{
  
     Address obj = new Address();
  }
  
    we are able to achieve loose coupling in between classe 
	by using has-a relation 
	
	

Parent.java:
````````````
//parent class cum busines logic class
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	public void sub(int x, int y)
	
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test7.java(execution logic class):
````````````````````````````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		
		Child obj = new Child();
		obj.sum(2, 3);
		obj.sub(4, 3);
		
	}
}

  
 note: 
 why constructor should not be inherited.?
 
 
class Parent{

  Parent(){
  
  }
}
class Child extends Parent{
   
   Child(){
   
   }
}
 
 
 
 
 
super:
``````
super is a java reserved keyword.
it is always refering immediate parent class properties.

  
  super at variable level
  super at method level
  super at constructor level.
  
  
example:
````````
//parent class cum busines logic class
public class Parent {
	
	int x=100;
	
	
	
}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	int x=200;

	public Child()
	{
		System.out.println(x);
		System.out.println(super.x);
	}

}

Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}
 
  
note:
`````
writing the super() is optional for to invoke the parent class default 
constructor

note:

writing the super(..) is mandatory to invoke parent class parameterized 
constructor when there is no default constructor.


Parent.java:
````````````
//parent class cum business logic class
public class Parent {

	public Parent(int x, int y)
	{
		System.out.println("iam from parameterized constructor-parent");
	}

	
	
}

Child.java:
```````````
//child class cum business logic class
public class Child extends Parent {

	
	public Child() {
		//invoke parent class parameterized constructor
		super(2,3);
		System.out.println("iam from default constructor-child class");
		
	}

}


Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}

  
note:
`````
for every constructor super()is added automaticlly by the java compiler which 
internally invokes parent class default constructor.

 
assignment: write a program which describes super at method level.



note:
`````
multiple inheritance is not possible through the concept of classe(s) , because 
of we will get ambiguity issue if two parent classes are maintaining same 
properties.

this problem we can achieve by using interface concept.


 class Object{
 }

 class A extends Object
 {
 }
 class B extends A
 {
 }
 class C extends B
 {
 }

note:
````
every java class is an example of inheritance or
every java class is a sub class or child class.

because for every java class whether it is predefined or user defined 
Object class is acting as a parent class.


assignment:
`````````````
write one program on Object class methods(11 methods)



note:
````
difference between this() and super()?

 this()or this(..) 
  
   ->refering current class default or parameterized constructor(s)
  
 super() or super(..)
 
   ->refering parent class default or parameterized constructor(s)
   
 super.<variablename>
   ->refering parent class variable 
   
 super.methodname()
  
   ->refering parent class method.
   
 
 
 
 
 
 polymorphism:
``````````````
it is the process of defining one action into many forms.

  types of polymorphism
  
   
   -compile time polymorphism
   
     -this polymorphism can be decided at compiletime by the java compiler
	 -when we call the method , method call is binded to which method will 
	  be decided at compiletime by the java compiler based on the reference 
	  variable.
	  
	  
	  
	  
   -runtime polymorphism
   
   
in java, how we can achieve this polymorphism?

  we have two concepts 
  
   1.method overloading
   2.method overriding
   
   
method overloading:
 
   method name is same
   but signature is different
   
    -type of parametrs
	-no.of parameters
	-atleast order of parameters
	
	
advantages of method overloading:
`````````````````````````````````
1.it improves the readability of written code
2.it adds cleanliness to the code written
3.it can be used on constructors also so that we can 
  create different objects by passing different data.
  
  
  note:
  to achieve method overloading , one class is more than enough.
  
  
note:
by changing returntype can we perform method overloading?

no, only by changing signature.


example:
````````
//example for method overloading cum compiletime polymorphism
public class Test8 {
	
	public void sum(int x, int y)
	{
		System.out.println("Integer sum: " + (x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum: " + (x+y));
	}

	public static void main(String[] args) {
		//objcet declaration at compiletime
		Test8 obj;
	    //object creation at runtime	
		obj=new Test8();
		
		obj.sum(2, 3);
		obj.sum(4.5,4.5);
		
	}
}

note:
`````
we can achieve the method overloading using object reference 
variable. 


method overriding:
``````````````````
-method name is same
-but logic is different from parent class to child class.

note:
to achieve method overriding minimum we require 
two classe(s) with parent-child realtion.


why should we go for method overriding?
```````````````````````````````````````
we have already parent class method has some logic
if we don't require or if we want to provide some new logic 
then we can go for method overriding.

Object 
  -toString()
  -className@HashCode
  
  
rules for method overriding:

 1.method must have the same name as in the parent class.
 2.method must have the same parameter as in the parent class.
 3.there must be an is-a realtionship.
 4.@Override annotation is recommended while we are overriding.
 
 
Parent.java:
````````````

public class Parent {

	public void sum()
	{
		System.out.println("sum-parent");
	}
	
}

Child.java:
````````````
public class Child extends Parent {

	@Override
	public void sum()
	{
		System.out.println("sum-child");
		//call the super class method
		super.sum();
	}
}

Test7.java:
````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		//Child obj = new Child();
		//Parent obj = new Parent();
		Parent obj=new Child();
		//Child obj =new Parent();
		obj.sum();
		
	}
}


note:
`````
based on the object type which method will be associated with 
which method that will be decided is called as 
runtime polymorphism.

based on the object reference varaible it is not possible.


static methods are not participating in method overriding.


note:
`````
while we are overriding we are allowed to increase the scope of the 
property not possible to decrease the scope of the property.

  private -> default -> protected ->public 

  
private properties are not eligible for method overriding, since private
properties only we are able to access within the class not from outside 
the classe(s).


final methods/properties are not eligile for method overriding, since 
final properties are constants ,  modifications are not possible.




String class api in java:
``````````````````````````
String is a predefined class available in java.lang package.

purpose: to store the series of characters.


in how many ways we can create the String object 

 -> two ways
 
 1.using String literal
 2.using new keyword
 
 
 
 String s1 = "Rama";(it gets stored inside scp memory area which is the part of 
 heap memory area which is the part of jvm which is the part of ram)
 
 
 String s2 = new String("Rama");
 (it gets stored inside heap memory area )
 
 
 note:
 `````
  scp memory area will not allow duplicates
  
  where as heap memory always creates new object irrespective
  of whether it is same or different.
  
  
 
String s1 = new String("rama");
String s2 = new String("rama");

 

String class object is immutable in nature.


unmodifiable 


->once we create any String object, on top of existing String object 
we could not perform any manipulations/modifications 

how to compare the String:
``````````````````````````
 ->by using == operator(Reference comparision operator)
 ->by using equals() or equalsIgnoreCase()
 ->by using compareTo() or compareTOIgnoreCase()
     -compareTo() compares Strings based on lexigraphical comparision.
	 -based on unicode values.
	 
	 
example:
````````
//program on string comparisions -different ways 

public class Test5 {
	
	public static void main(String[] args) {
		
		//string literal approach -it won't allow duplicates
		String s1 = "rama";
		String s2 = "rama";
		String s5 = "Rama";

		//to find out unicode value of character based on the index
		System.out.println(s1.codePointAt(0));
		System.out.println(s5.codePointAt(0));
		
		
		System.out.println(s1==s2);//true
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s5));//false
		System.out.println(s1.equalsIgnoreCase(s5));//true
		System.out.println(s1.compareTo(s2));//0
		System.out.println(s1.compareTo(s5));//32
		System.out.println(s5.compareTo(s1));//-32
		System.out.println(s1.compareToIgnoreCase(s5));//0
		
		//using new keyword -it creates everytime as a new object
		String s3 = new String("hyd");
		String s4 = new String("hyd");
		
		System.out.println(s3==s4);//false
		System.out.println(s3.equals(s4));//true
		
	}

}

 
checking immutability vs mutablity using String,StringBuffer and StringBuilder:


public class Test6 {

	public static void main(String[] args) {
		
		//immutable object
	 String s1 = "Rama";
	 s1.concat("hyd");
	 System.out.println(s1);//Rama
	   //mutable object
	 StringBuffer s2 = new StringBuffer("Rama");
	 s2.append("hyd");
	 System.out.println(s2);//Ramahyd
	  //mutable object
	 StringBuilder s3 = new StringBuilder("Rama");
	 s3.append("hyd");
	 System.out.println(s3);//Ramahyd

	}
}


note:
using StringBuffer & StringBuilder we can create mutable Strings but 
differnce is StringBuffer methods are synchrnozed(thread safe) methods where as
StringBuilder methods are non-synchrnized(not thread safe) methods.

example on frequently used methods of String class:
````````````````````````````````````````````````````

public class Test6 {

	public static void main(String[] args) {
		
		String s1 = new String("Rama");
		String s3= new String("Rama");
		String s4 = new String("Rama,hyd,software,hardware");	
		String s2 = "  banga  lore   ";
		int value=40;
		String s5 = String.valueOf(value);
		
		String str = new String("welcome to java sessions");
	
		System.out.println("length of the stirng: " + s1.length());
		
		System.out.println("character at 0th position: " + s1.charAt(0));//R
		
		System.out.println(s1.concat("hyd"));//Ramahyd
		
		System.out.println(s1.contains("R"));//true
		System.out.println(s1.contains("j"));//false
		
		System.out.println(s1.endsWith("j"));
		System.out.println(s2.indent(2));//  banga  lore
		System.out.println(s2.indent(-2));//banga  lore
		System.out.println(s2.indent(0));//  banga  lore	
		System.out.println(s1.intern()==s3.intern());//true
		System.out.println(s1.substring(1));//ama
		System.out.println(s1.substring(0, 3));//Ram
		String[] split = s4.split(",");
		for(String s:split)
		{
			System.out.println(s);
		}
		
		System.out.println(s5+10);
		System.out.println(s2.length());
        System.out.println(s2.strip().length());
        
        System.out.println(str.matches("welcome(.*)"));
        System.out.println(str.matches("tutorials"));
 
	}
}
















abstraction:
````````````
  -security
  -enhancements
  -manitability
  -modularity
  
 
hiding the implementation details and showing only services to the end users.
  
abstraction is also one of the oop principle.

   -abstract classe(s)(partial abstraction)
   -interface
   

abstract class:
````````````````
 ->concrete classes (fully defined classes)
 ->abstract class 
 
 abstract class is a combination of both 
 defined methods 
 and as well as undefined methods
 
 undefined method/abstract method:
   
     public abstract void getRateOfInterest();->method declaration
	 
	 
	 
note:

  if a class contains atleast one abstract method it is highly 
mandatory to make corresponding class also as 
abstract class using abstract keyword before the class declaration.



    abstract class Test{
    public abstract void m1();
	public void m2(){}
	
	public Test()
	{
	}
	}

  
 for a single abstract class, how many implementation classe(s) we can define?
 
 as many as you want.

 
  class Test1 extends Test
  {
    public void m1(){}
	
	public Test1()
	{
	  super();
	}
  }


  Test obj = new Test1();
  
  obj.m1();
 

in abstract class, can we define constructor(s)?
yes

Bank.java:
```````````


abstract public class Bank {

	 abstract int getRateOfInterest();
}

SBI.java:
``````````

public class SBI extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5;
	}

}

CityBank.java:
```````````````

public class CityBank extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7;
	}

}



TestBank.java:
``````````````

public class TestBank {
public static void main(String[] args) {
	
	Bank b ;
	b=new SBI();
	System.out.println("sbi bank rate of interest is : " + b.getRateOfInterest());
	
	b =new CityBank();
	System.out.println("city bank rate of interest is : " + b.getRateOfInterest());
}
}


example on abstract class with constructor:
````````````````````````````````````````````

abstract public class Bike {
	
	Bike()
	{
		System.out.println("bike is created");
	}

	void changeGear()
	{
		System.out.println("gear changed");
	}
	
	abstract void run();
}


Honda.java:
````````````

public class Honda extends Bike {

	@Override
	void run() {
		
		System.out.println("running safely...");

	}

}

TestAbstraction.java:
`````````````````````
public class TestAbstraction {
public static void main(String[] args) {
	
	
	Bike obj = new Honda();
	obj.run();
	obj.changeGear();
}
}




interface:
``````````

interface
implemetnatin class
execution logic class



interface i1
{
  public abstract void m1();
  public static final int x=100;
}

note:
by default interface methods are public abstract 
and by default interface datamembers are public static final.


 extends: 
 
 using extends keyword we can take the properties from 
 class to class and interface to interface (homogenious)
 
 implements:
 
 using implements keyword we can take the properties from 
 interface to class(heterogenious)
 
 assignment:
 do one program on top of interface
 
interface inheritance and multiple inheritance:
```````````````````````````````````````````````

public interface i1 {
	
	void m1();

}


i2.java:
`````````

public interface i2 {
void m2();
}


Test9.java:
```````````

public class Test9 implements i1,i2{

	@Override
	public void m1() {
		System.out.println("m2 body");

	}

	@Override
	public void m1() {
		System.out.println("m1 body");

	}
	
	public static void main(String[] args) {
     	i2 obj;
		obj = new Test9();
		obj.m1();
		obj.m2();
	
	}

}

encapsulation:
``````````````

encapsulation = datahiding + abstraction

encapsulated class:

 class is the best example for an encapsulation.
 
 by declaring datamembers as private 
 and by defnining public setters and getter methods(s).
 
 
Student.java:
``````````````

public class Student {

	//data hiding
	private int stid;
	private String stname;
	
	//abstraction 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	
}
Test10.java:
````````````

public class Test10 {
	
	public static void main(String[] args) {
		Student student = new Student();
		
		student.setStid(100);
		student.setStname("Rama");
		
		System.out.println("student id: " + student.getStid());
		System.out.println("student name: " + student.getStname());
		
	}

}




exception handling :
 ``````````````````
 
 erros are of two types
   
    ->compiletime errors->poor in syntaxes
	->runtime errors-> when we pass invalid input
	
	            ->100/20 ->5
				->100/0 ->java.lang.ArithmeticException: /by zero 
 
   exceptions
   
   
 drawbacks of exceptions:
 ````````````````````````
 ->control terminates abnormally
 
 --
 -- int x = 100/0;
 --
 1000
 
 ->we are not able to maintain normal flow of execution 
 ->if exception occurs , we will get system error messages
   which are not understable by end user which is not 
   recommended.
   
   
 we have to handle the exception
 
  how can we handle the exceptions?
  
     ->try
	 ->catch
	 ->finally
	 ->throws
	 ->throw
	 
	 
 types of exceptions:
 
   ->pre-defined exceptions
   ->user-defined exceptions
   
 

java.lang.Object
 
      Throwable

Error       Exception 


 ->pre-defined exceptions
  
     ->asynchronous exceptions ->if any hardware related issues
	 
	   java.lang.OutOfMemoryException,stackOverFlow ...
	   
	 ->synchronous exceptions->if any programatical errors
	 
	            ->checked exceptions->ex: SQLException,IOException,...
				->unchecked exceptions-> RuntimeException
				
 
 
   hallticket -> HallTicketNotFoundException
   
   pen -> PenNotFoundException
   
   BombBlastException
   
 
 -predefined exceptions for to handle universal problems.
 
 
   jvm internally throws a particular/specific exception
   
   
 
 without handling the exception:
 ``````````````````````````````
 package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
		
		System.out.println("division is: " + z);
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
	}

}


try:
````
try block is used to keep 

 ->problematic statements which causes problems at runtime.
 
 syntax:
   
     try
	 {
	   //problematic statements
	 }
 

catch block:
`````````````
 ->to catch the exception
 
 syntax:
 
   catch(<exceptionclassname> <referencevariablename>)
   {
    //user friendly message
   }
   
note:
while we are handling the exceptions, we should always follows the order
which is from  specific to general otherwise we will get compile time error
saying that unreachable code for the java compiler.

example:
`````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
	     	System.out.println("division is: " + z);
		}
		
		
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		catch(NumberFormatException nfe)
		{
			System.out.println("please pass only numerics");
		}
		
		catch(ArrayIndexOutOfBoundsException ai)
		{
			System.out.println("please supply the input");
		}
	
		catch(RuntimeException re)
		{
			System.out.println(re);
			
		}
		
		
		
		System.out.println("Rest of the statements  executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
		
		
	}

}









nested try block:
`````````````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			
			try {
				System.out.println("divide by 0");
				int x = 40/0;
			}
			catch(ArithmeticException ae)
			{
				System.out.println(ae);
			}
			
			try {
				int x[] = new int[5];
				x[5]=4;	
			}
			
			catch(ArrayIndexOutOfBoundsException ai)
			{
				System.out.println(ai);
			}
			
			System.out.println("other statements");
		}
		//catch block of outer try block
		
		catch(Exception e)
		{
			System.out.println("handled the exceptions");
		}
		
		System.out.println("Normal flow");
		
	}

}


finally block:
``````````````

package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}
		
		
		finally
		{
			System.out.println("Finally block executed");
		}
		System.out.println("Normal flow");
		
	}

}

finally block always executed whether exception occurs or not?
note:
we are writing the finally block is for keeping closing related logic
or to close the resources.

 like conneciton closeing logic, closing the file objects etc.. to escape
 from memory leakage problem or data leakage problem(s).
 
 
->try with finally block is possible
->exclusive only finally block is not possible.
->try ,catch and finally blcoks is possible
->in between try and catch is it possible to write finally block ->no
->nested try block with finally also possible.

 

   


throws:
```````

throws keyword gives an indication to the calling fucntion to keep 
called function under try and catch block.



//called
class Test{
 void div() throws ArithmeticException
 {//ae}
 }

//calling 
class Demo{
  Test ob = new Test();
  try{
  obj.div();
  }
  catch(AE ae){
  }
}


parseInt()

sleep() throws InterruptedException 

Test1.java:
```````````
package com.citus.exceptions;
//called program
public class Test1 {
	
	public void div() throws ArithmeticException
	{
		int x=100/0;
		
	}

}


Test2.java:
```````````
package com.citus.exceptions;
//calling program
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		try {
		obj.div();
		}
		catch(ArithmeticException ae)
		{
			System.out.println(ae);
		}
		System.out.println("Rest of the statements");
		
	}

}

throw:
``````
throw is a java reserved keyword which is used to throw an exception explictly.

 int x = 100/0;
 
    ArithmeticException ae = new ArithmeticException();
	

note:
we are using this throw keyword to throw a user defined exception explictly 
not for pre-defined execption.


syntax:

   throw new <exceptionclassname>();
   
note:
every exception internally it is a class.


example:
````````
package com.citus.exceptions;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		String str = "rama";
		if(str.startsWith("r"))
		{
			try {
			throw new ArithmeticException();
			}
			catch(ArithmeticException ae)
			{
				System.out.println("String is invalid");
			}
		}
		else
		{
			System.out.println("String is valid");
		}
		
		
	}

}


user defined exceptions using throw keyword:
``````````````````````````````````````````````
package com.citus.exceptions;

public class Test3 {
	
	public void checkProduct(int weight) {
		if(weight>=100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ipe)
			{
				System.out.println("product weight must be greater than 100kgs");
			}
		}
		
	}
	public static void main(String[] args) {
		
		Test3 obj = new Test3();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
class InvalidProductException extends Exception 
{
}

note:
`````
to make normal java class as an exception class, make sure that class must be
extending from Exception class.


exception handling with method overriding:
```````````````````````````````````````````
.if the superclass method doesnot declare an exception,sub class overriden 
 method cannot declare the checked exception but it can declare unchecked
 exception.
 
.if the superclass method declares an exception, sub class overriden method 
can declare same,subclass exception or no exception but cannot declare 
parent exception.
     sum() throws RuntimeException{}
	 
	 sum()throws Exception{}

example for exception propagation:
``````````````````````````````````
package com.citus.exceptions;


public class Test4 {
	
	void m()
	{
		int x=7/0;
	}
	void n()
	{
		m();
	}
	void p()
	{
		try {
		n();
		}
		catch(Exception e)
		{
			System.out.println("exception handled");
		}
	}
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.p();
		System.out.println("normal flow");
	}

}

note:
````
an exception is first thrown from the top of the stack and if it is not caught,
it drops down to the call stack to the previous method.
if not caught there,the exception again drops down to the call stack to the 
previous method , and so on until they are caught or until they reach 
the very bottom of the call stack 

This is called exception propagation.
 









	 
	 
	 
	 
	 