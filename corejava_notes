


 
    java:
	
	
	 ->programming languages
	 
	     pop
		 oop
		 mop
		 sop
		 ...
		 
	 
	 ->to make the software/application
	 
	 ->object oriented programming language
	 
	 ->using java what applications we can develop?
	 
	 
	 
	  we have two types of applciations
	  
	  
	    ->standalone applications/desktop applications -results are not sharable
		->distributed applications-results are sharable across the globe
		gmail.com
		facebook.com etc..
		
		
	 
	 jamesgosling -> in three editions
	 
	  jse->java standard edition --> standalone applications
	  jee->java enterprise edition -> distributed applications & standalone apps
	  jme->java micro/mobile edition -> 
	 
	 
if any requirement -> 

   program -> set of instructions

every programmer must follow some rules/syntaxes -> 

     
java -> sunmicrosystem 
     -> oracle 

	 
	 <datatype> <variablename>=<value>;
	 
	 

for java program, there is basic structure

 
  every java program must starts with by defining a class.
  
  
  without defining a class there is no java program .
  
  
  syntax:
     
	   class <classname>
	   {   
	      
	      public static void main(String[] args)
		  {
		    //logic
		  }
		  
	   }

note: java is case senstive programming language.

note: every java reserved keyword must be in lowercase.

note: without defining the main(), we can compile the program, but we can't run 
      the program because execution of java program should starts from main().
	  
	  

  i want to write the java program?
  
    prerequisites to write the java program?
	
	1.download the java software(jdk)->open source
	
	2.install this software
	
	3.select the editor(notepad,notepad++,eclipse,netbeans,intellij)
	
	4.write the java program 
	
    5.save the java program (<filename>.java)
	
	6.compile the java program (javac <filename>.java)
	
	7.run the java program (java <classname>)
	
	
why should we go for compiling the java program?

  java compiler will check for all the syntaxes
  
  java compiler -> compiletime error
  
  java compiler -> will generate .class file
  
  .java file contains source code
  .class file contains byte code
  
  byte code:
  
    byte code can not be understandable by human 
  
    byte code can be understandable by jvm(java interpretor)
	
	  jvm -> byte code and converts it into machine level code 
	  
	  
java compiler -> compiles the program (Checking the syntaxes)
java interpretor(jvm) -> executes the program (converting bytecode to machine level code)

 
in java, to display any information in the console one statement we have to use?

    System.out.println("welcome to java"); 
    

to compile 
   
    javac Welcome.java

to execute

     java <classname>
	 java Infosys
	 
	 
open the command prompt


in real world , we never use these basic editors to develop the programs

ide's ->integrated development environment


 eclipse
 myeclipse
 intellij
 netbeans
 bluej
 visualstudio
 ...
 
how to download and install the eclipse in your mahines?

note:
the code which we are writing in the ide is autocompiled


   jdk vs jre vs jvm
   
   
java development kit

   it provides two environments
   
         -dev environment(develop the java programs)
		 -runtime environment(execute the java programs)
		 
		 
jre:
   java runtime environment

      ->runtime environment (only we are able to execute the java applications)
	  
	  
jvm:
   java virtual machine

   
	 ->using this we can develop the actual java program
	 
	 
	 
'every java program should starts with by defining class 

  class <classname>
  {
   //variables

   //methods

  }   
	 
	 
variable:
``````````
variable is used to store the data

  it is a name which we are giving to memory location .

syntax:
  
   <datatypename> <variablename> = <value>;

  int x=100;  

  int 100=100;-invalid

  int int =100;//invalid

  int _xyz=100;

  int x123 =100;

  int 123x=100;

  int $xyz=123;

  int xyz*123=100;  
	 
	 
A variable name can consist of Capital letters A-Z, lowercase letters a-z digits 0-9, and two special characters such as _ underscore and $ dollar sign.

The first character must not be a digit.

Blank spaces cannot be used in variable names.

Java keywords cannot be used as variable names.

Variable names are case-sensitive.

There is no limit on the length of a variable name but by convention, it should be between 4 to 15 chars.

Variable names always should exist on the left-hand side of assignment operators.	 

example:
`````````


public class Welcome {
	
	public static void main(String[] args) {
		
		int x=100;
		//int int =100;
		int _xyz=123;
		
		int $xyz=123;
		byte b1 = 127;
		
		float f = 12.3467676f;
		double d = 56.6776565656556656;
		char c = 'a';//2 bytes
		boolean b =true;
		
		//int xyz abc = 123;
		//int xyz*123=12;
		//int 1xyz=123;
		
	}

}






Primitive Data Type: In Java, the primitive data types are the predefined data types of Java. They specify the size and type of any standard values. Java has 8 primitive data types namely byte, short, int, long, float, double, char and boolean.


datatypes in java:

   4 types 
   
    integer 
	   byte
	   short
	   int
	   long
	   
	float 
	   float
	   double
	   
	charcter
	   char
	   
	boolean 
	   boolean (true/false)
	   
	
based on the value and the range will decide a specific datatype

every datatype is having 
 their own memory size and range 
 
  
  int x = 100;(4 bytes)
  
  
byte datatype -> 1 byte -> 8 bits


 -2^n-1 to 2^n-1 -1
 
 -2^7 to 2^7 -1
 
 -128 to 127
 
  byte b = 130;
  
 
usually float datatypes we are using to store decimal values
by default decimal data can be considerd as double type 

 
float f = 23.45f;
	 
	 
	 
method:
````````
method is the place where we are writing the logic to perform some operations 
based on the requirement.



syntax:

  
     [accessmodifier] <returntype> <methodname>([paramters if any])
	 {
	 
	     //logic
	 }


ex:
     public void sum(int x, int y)
	 {
	   System.out.println("sum is: " +(x+y));
	 }
	 

note:
if a method is not returning any value , we have to specify returntype as 
void


 int getSalary()
{
  return 50000;
}


note:
return value and retuntype must be compatible otherwise we will get 
compiletme error.


System.out.println(getSalary());
//output as 50000



int getSum(int x, int y)
{
  return x+y;
}

   getSum(4,5);

Hungarian notation /camelcase notation:

recommendation:
 
 getAge()
 getStudentInfo()
 getSalary()
 getThreadStatus()
 setMarks();
 
example:
`````````

public class Demo {
	
	
	static byte b=100;
	public static void display()
	{
		System.out.println("byte value is " + b);
	}
	
	public static void main(String[] args) {
		//calling the method
		display();
		
	}

}

example:
`````````

public class Demo {
	
	
	
	public static int getSum(int x, int y)
	{
		return x+y;
	}
	
	public static void main(String[] args) {
		int result = getSum(120,345);
		
		System.out.println("sum is : " + result);
		
	}

}



instance vs static:
```````````````````


     why java is oop language?
	 
	 answer: since it follows oops principles.
	 
	 oops principles: 
	  
	   we have 4 oops principles
	   
	 who derived these oops principles?

          omg(object management group)
          candian organization 
		  
	     
		  
java is one of the object oriented programming language.
.net,python,php..


  inheritance
  polymorphism
  abstraction 
  encapsulation 
  
  
 in java, how can we achieve these principles?

  we have two concepts

  1.class
  2.object

  
 object: 
  
  note:
  
  when we define a class, memory spaces will not be allocated
  for datamembers.
  
  we should go for creating the object
  
  
  for a single class, how many object(s) we can create?
  
   as many as we want based on the requirement.
   
   in a college, 
      -> 1000 students
	  
Student anita = new Student();	  
  
  
object:
```````` 
  instance of a class is known as object.
  
  instance: allocating sufficient amount of memory space for the non-static
            data members which we are declaring inside the class.
			
			
syntax:
```````
   <classname> <objectname> = new <classname>();
   Student anita = new Student();

   new -> dynamic memory allocation operator
   
example:
`````````

public class Demo {
	
	int x=200;
	public void display()
	{
		System.out.println("integer value is : " + x);
	}

	public static void main(String[] args) {
		
		
		//creating the object
		
		
		Demo obj = new Demo();
		
		System.out.println("integer value is : " + obj.x);
		
		obj.display();
		
		
	}

}

note:
````
using . operator we are able to access class level datamembers.

   
  
  
  
 instance vs static:

instance  -> non static 
static -> static


 int x;
 static int x;
 
 
note:
to make any property as staic we should add static keyword before method or variable
declaration.

 public void m1()
 {
  //instance area 
 }
 
 public static void m2()
 {
   //static area
 }
  
  
  the area which belongs to non-static /instance method is known as 
  instance area
  
  the area which belongs to static method is known as static area
  
  
note:
`````
for non static/instance properties memory will be created whenever we create
the object.


note:
`````
from static area to access instance properties using object name it is possible.
from static area to access static properties we have threee possibilities

   1.using class name
   2.diretly we can access
   3.using object name(it is not recommended)
  
if you define any property as static, memory will be created only once 
at the class loading time before object creation.


note:
from the instance area , we can access instance properties directly 
and as well as staic proeprties using class name or directly.



example:
```````

public class Student {
	//instance properties
	int stid=100;
	String stname="Ram";
	
	//static property
	static String collegeName="cbit";
	
	//instance method
	public void display()
	{
		//instance area
		System.out.println("student id: " + stid);
		System.out.println("student name: " + stname);
		System.out.println("student collegename: " + collegeName);
		
	}
	
	
	public static void main(String[] args) {
		//static area
		Student st1 = new Student();
		System.out.println("student id: " + st1.stid);
		System.out.println("student name: " + st1.stname);
		System.out.println("college name: " +collegeName);
		System.out.println("===================");
		
		st1.display();
		
		
	}

}


public static void main(String[] abc)
{
}

why main() method is taking array of String as an argument?

 -> to deal with command line arguments
 
 command line arguments:
 
 these are the arguments which we are passing from the command line while 
 we are executing the java program.
 
 
 
 java Test1 rama infosys
 ramainfosys
 
 
 

when we execute the java program , jvm internally invokes main() 


we have 8 datatypes


Wrapper classes

 are available in java.lang package
 
 
short -> Short -> parseShort(String s)->short
byte  ->Byte
int
long 

float
double
char
boolean


example:
````````

public class Test1 {
	
	public static void main(String[] args) {
	System.out.println("sum is : " + (Integer.parseInt(args[0])+Integer.parseInt(args[1])));
		
	}

}


constructor:
`````````````

constructor is a special member method 
which must be similar to class name.


->constructor should not return any thing even void also.
->constructor name must be similar to class name.


purpose:
to initialize the object
  ->assign the values to the datamembers of the class.
  
  
example without constructor:
````````````````````````````

public class Test1 {
	//class level variables
	int x, y;
	
	public void assign(int p,int q)
	{
		x=p;
		y=q;
	}
	
	public void sum()
	{
		System.out.println("sum is: " + (x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.assign(10,20);
		obj.sum();
		
	}

}

note:
whenever we create the object corresponding constructor will be invoked.


with constructor:
`````````````````

public class Test1 {
	//class level variables
	int x, y;
	
	public  Test1()
	{
		x=100;
		y=200;
	}
	
	
	public void sum()
	{
		System.out.println("sum is: " + (x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.sum();
		
	}

}


types of constructors:
````````````````````````

-default constructor->constructor without paraeters
-parameterized constructor


when we don't have any constructor inside a program 
then java compiler will generate one constructor 
i.e system defined default constructor
 -> to assign the default values
 
 user defined default constructor -> to assign our own values.
 
 
 
 
 note:
 
 java compiler will generate system defined default constructor if 
 program has no constructor(s) or if it has user defined constructor .
 
 
 note:
 java compiler will not generate this system defined default constructor 
 if program has parameterized constructor.
 
  default constructor is available in only one form 
  where as parameterized constructor is available in many forms.
  
  
 example:
 ````````
 
public class Test1 {
	// class level variables
	int x, y;

	//parameterized constructor
	public Test1(int p, int q) {
		x=p;
		y=q;
	}

	public void sum() {
		System.out.println("sum is: " + (x + y));
	}

	public static void main(String[] args) {

		Test1 obj = new Test1(10,20);

		obj.sum();

	}

}


this:
this is the java reserved keyword which is used in following 
two purposes.

1. if class level variables and constructor level parameters are same 
to differentiate we have to use this for the class level variables.

2.to call current class constrcutor from any other constructor of a class.

  this() -> it will call current class default constructor
  this(..) -> it will call current class parametrized constructor
  
  
note:
constructor call must be always first executable statement inside a constructor.


conditional statements:
````````````````````````
Conditional statements define conditions that are true or false and then execute based on whether or not the condition is true

java if statement is used to test the condition 
it checks boolean condition true or false.


  -if statement
  -if else statement
  -if else if ladder
  -nested if statement


syntax

if(condition)
{
 //code to be executed
}

syntax:

 if(condition)
 {
   //code to be executed
  }
  else
  {
  //code to be executed
  }
  
 

example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=17;
		//check if the number is divisible by 2 or not
		
		if(number%2==0) {
			System.out.println("even number");
			
		}
		else
		{
			System.out.println("odd number");
		}
		
		
	
		
		
	}
	
	
}


assigment:
`````````
check if the given year is leap year or not using 
if else?


  
 ternary operator:
 `````````````````
 we can also use ternary operator(?:) to perform the task of if..else statement.
 
 it is a shorthand way to check the condition.
 
 
 if the condition is true the result of ? will be retunred
 if the condition is false the result of : will be returned.
 
 
example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=18;
		//check if the number is divisible by 2 or not
		
		String result =(number%2==0)?"even number":"odd number";
		
	  System.out.println(result);
		
		
	}

}

if-else-if ladder statement:
`````````````````````````````
it executes one condition from multiple statements.

syntax:
 if(condition1)
 {
   //code to be executed
 }
 else if(condition2)
 {
   //code to be executed if condition2 is true
 }
 else if(condition3)
 {
   //code to be executed if condition3 is true
 }
 ..
 else
 {
   //code to be executed if all conditions are false.
 }
 
assignment:
````````````
write a program of grading system based on student marks
using if-else-if ladder statement.


assignment:
write a program to check positive,negative or zero?


nested if statement:
`````````````````````
if{

  if{
  }
 }
 
example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int age=15;
		int weight=48;
		//applying condition
		if(age>=18)
		{
			if(weight>50)
			{
				System.out.println("you are eligible to donate blood");
			}
			else
			{
				System.out.println("you are not eligible to donate blood");
			}
		}
		
		else
		{
			System.out.println("age must be greater than 18");
		}
		
	}
	
	
}

switch statement:
``````````````````
switch statement executes one statement from multiple conditions.

switch statement works with byte,short,int ,long,String,enum and some 
wrapper types.

syntax:

 switch(expression)
 {
 
 case value1:
 //code to be executed;
 break;//optional
 case value2:
 //code to be executed;
 break;
 ...
 
 ...
 default:
 //code to be executed if all cases not matched
 
 }
  


assignment
````````````
finding month name for the given number?

example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		
		int number=17;
		String month="";
		//switch statement
		switch(number) {
		
		//case statements with in the switch blokc
		
		case 1: month="january";
		break;
		case 2: month="February";
		break;
		case 3: month="March";
		break;
		case 4: month="April";
		break;
		case 5: month="May";
		break;
		case 6: month="June";
		break;
		case 7: month="July";
		break;
		case 8: month="August";
		break;
		case 9: month="September";
		break;
		case 10: month="October";
		break;
		case 11: month="November";
		break;
		case 12: month="December";
		break;
		
		default: System.out.println("invalid month");
		
		
		
		}
		
		System.out.println(month);
	}
	
}

assignment:
````````````
program to check vowel or consonant?


switch case with enum type:
```````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		Day[] DayNow = Day.values();
		
		for(Day Now: DayNow)
		{
			switch(Now)
			{
			case Sun:
				System.out.println("sunday");
				break;
			case Mon:
				System.out.println("monday");
				break;	
			}
		}
		
		
	}
}


loops:
``````

if we want to execute the portion of code repeatedly based on the condition 

 in java, how many loops we have?
 
  for loop
  while loop
  do while loop
  enhanced for loop(for each loop)
  

for loop is used to iterate a part of the program several times.
if the number of iteration is fixed,it is recommended to use for loop.


inside for loop 

 we have to initialize the variable
 we have to check the condition 
 we have to increment/decrement the value.
 
 syntax:
 
  for(initialization;conditionchecking;increment/decrement)
  {
    //statement 
  }
  
example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		for(int i=1;i<=5;i++) {
		  System.out.println("welcome to java session");
		}
	}
}



nested for loop:
```````````````

public class Test1 {
	
	
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=3;i++) {
	
			//loop of j
			for(int j=1;j<=3;j++)
			{
				
				System.out.println(i + " " +j);
			}
			
			
		}
	}
}


pattern matchig example using nested for loop:
`````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=5;i++) {
	
			//loop of j
			for(int j=1;j<=i;j++)
			{
				
				System.out.print("*");
			}
			System.out.println();
			
			
		}
	}
}


while loop:
```````````
it is used to iterate a part of the program repeatedly until 
the specified condition is true
as soon as the boolean condition is false, the loop automatically stops.

if the number of iteration is not fixed, it is recommended to use
while loop.

example:
```````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}
}


display the first 10 numbers in reverse order using while loop?


public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}
}


displaying the even numbers using while loop in reverse order:
```````````````````````````````````````````````````````````````

public class Test1 {
	
	
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			if(i%2==0)
				System.out.println(i);
			i--;
		}
	}
}

do while:
`````````
 atm machines
 
 ->enter password:
 
 java do while loop is called an exit control loop
 therfore unlike while and for loop 
 the do while loop check the condition at the end of  the loop body.
 

 It is executed atleast once because condition is checked 
 after loop body.

		syntax:
			do{
			  //code to be executed or loop body
			 }
			 while(condition);


		example:
		````````

		public class Test1 {
			
			public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
			 
			public static void main(String[] args) {
				
				int i=1;
				do {
					System.out.println(i);
					i++;
				} while (i>=10);
			}
		}



operators:
```````````
operator in java is a symbol that is used to perform 
operations

there are many types of operators in java
 
-unary operators
-arithmetic operators
-shift operator
-relational operator
-bitwise operator
-logical operator
-ternary operator
-assignment operator

  
 example on unary operator:
 
 
 
public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int x=10;
		System.out.println(x++);//10
		System.out.println(++x);//12
		System.out.println(x--);//12
		System.out.println(--x);//10
	}
}

example:
`````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=10;
		int b=10;
		
	System.out.println(a++ + ++a);//10+12->22
	System.out.println(b++ + b++);//10+11->21
	}
}


~ and !
 
a=10
~a ->

example:
````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=10;
		boolean b= true;
		System.out.println(!b);//false
		System.out.println(~a);//-11
	}
}


example on bitwise operators:
``````````````````````````````

public class Test1 {
	
	
	 
	public static void main(String[] args) {
		
		int a=12,b=10;
		/*
		 * 01100 
		 * 01010 
		 * 00110 
		 * 16 8 4 2 1
		 */
		System.out.println(a&b);//8
		System.out.println(a|b);//14
		System.out.println(a^b);//6
		
		System.out.println(a<<3);
		//formula -> 2^n * a-> 2^3 * 12 =>96
		
		System.out.println(a>>2);
		//formular -> a/2^n -> 12/4 -> 3
		
	}
}





packages:
`````````
definition:
 package is a collection of classes, interfaces and sub packages
 
 
purpose:
````````
  ->reusability
  ->avoids naming conflicts
  

syntax:
```````
  package <packagename>;
  
  
naming convention:
```````````````````
<reverseof your companywebsite>.<projectname>.<modulename>;

package names are always must be in lower case.

ex:

->com.infosys.jse.packages;


  com.infosys.banking.withdrawl
  
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip


  examples:
  package p1;
//business logic class
public class Test1 {
	
	 public void sum(int x, int y)
	 {
		 System.out.println("sum is : " + (x+y));
	 }

}


Test2.java:
````````````
package p1;
//execution logic class
public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}
	
}


Test3.java:
````````````
package p2;
import p1.Test1;
public class Test3 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 2);
	}

}


we have two types of package(S)
 
 1.pre defined package(S)
 2.user defined package(s)
 

java.util package

 ArrayList al = new ArrayList();
 
 
note:
default imported package for every java application is java.lang 


example:
`````````
package p2;

import java.util.ArrayList;

public class Test4 {
	
	public static void main(String[] args) {
		
		
		ArrayList al = new ArrayList();
		
		String s = new String("Ram");
		
	}

}




access modifiers:
```````````````````

 we have 4 access modifiers
 
  private 
  default
  protected
  public 
  

int x;

it controls the visibility of the properties over the pacakge(s).


ccesmodifiers:
````````````````

it is used to control the scope of the visibility over the package(s).


  private 
  default(not a keyword)
  protected
  public
  
  
 private properties we can access only with in class 
 not able to access 
  same package subclass/non-subclass
  other package subclass/non-subclass

 default properties we can access 
  with in the class
  same pacakge subclass/subclass but not from 
  other package subclass/non-subclass

 protected properties we can access 
  with in the class 
  same pacakge subclass/non-subclass
  other package sub class but not from 
  other package non-subclass
 
when it comes to public from any where we can access there is no 
restriction.

 
pakage p1;
class Test1{}

pacakge p1.p2;
class Test2{}


 
 java.lang
 java.lang.reflect
 
 
 package p3;
 import p1.*;
 import p1.p2.*;
 class Test3
 {
 
 }
 
 
->by importing the main package only we are able to access main package 
proeprties 

->if we want to reuse sub package properties explictly we have to import 
sub pacakge.


 
 
 oops principles:
 ```````````````
 omg(object management group)
 

inheritance:
`````````````
  it is the process of taking the properties from one class to another 
  class.
  
  the class which is giving the properties is known as base/super/parent 
  class.
  
  the class which is taking the properties is known as sub/derived/child
  class.
  
  note:
  `````
  using extends keyword we can achieve the concept of inheritance.
  in the context of child class only we have to use extends keyword.
  
  types of inheritances:
  
   simple/single inheritance
   multilevel inheritance
    multiple inheritance
   hierarchical inheritance
   hybrid inheritance
   
   
   E
   
   D
  
  A B C
  
   
   class A 
   {}
   class B extends A{}
   class C extends A,B{}
   
  
 note:

using extends keyword we are able to derive single class from single class 
not from multiple classes or more than one class.

 
->reusability


note:
````
if we create the child class object, memory locations will be created for 
both parent class properties and child class properties where as 
if we create the object for parent class object, only we are able to access
parent class properties.


is-a relation 
``````````````
whenever one class inherits another class,it is called as 
an IS-A relationship.

HAS-A relation:
`````````````````
whenever an instance of one class is used in another class, it is called
HAS-A relationship.

  class Student{
  
     Address obj = new Address();
  }
  
    we are able to achieve loose coupling in between classe 
	by using has-a relation 
	
	

Parent.java:
````````````
//parent class cum busines logic class
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	public void sub(int x, int y)
	
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test7.java(execution logic class):
````````````````````````````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		
		Child obj = new Child();
		obj.sum(2, 3);
		obj.sub(4, 3);
		
	}
}

  
 note: 
 why constructor should not be inherited.?
 
 
class Parent{

  Parent(){
  
  }
}
class Child extends Parent{
   
   Child(){
   
   }
}
 
 
 
 
 
super:
``````
super is a java reserved keyword.
it is always refering immediate parent class properties.

  
  super at variable level
  super at method level
  super at constructor level.
  
  
example:
````````
//parent class cum busines logic class
public class Parent {
	
	int x=100;
	
	
	
}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	int x=200;

	public Child()
	{
		System.out.println(x);
		System.out.println(super.x);
	}

}

Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}
 
  
note:
`````
writing the super() is optional for to invoke the parent class default 
constructor

note:

writing the super(..) is mandatory to invoke parent class parameterized 
constructor when there is no default constructor.


Parent.java:
````````````
//parent class cum business logic class
public class Parent {

	public Parent(int x, int y)
	{
		System.out.println("iam from parameterized constructor-parent");
	}

	
	
}

Child.java:
```````````
//child class cum business logic class
public class Child extends Parent {

	
	public Child() {
		//invoke parent class parameterized constructor
		super(2,3);
		System.out.println("iam from default constructor-child class");
		
	}

}


Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}

  
note:
`````
for every constructor super()is added automaticlly by the java compiler which 
internally invokes parent class default constructor.

 
assignment: write a program which describes super at method level.



note:
`````
multiple inheritance is not possible through the concept of classe(s) , because 
of we will get ambiguity issue if two parent classes are maintaining same 
properties.

this problem we can achieve by using interface concept.


 class Object{
 }

 class A extends Object
 {
 }
 class B extends A
 {
 }
 class C extends B
 {
 }

note:
````
every java class is an example of inheritance or
every java class is a sub class or child class.

because for every java class whether it is predefined or user defined 
Object class is acting as a parent class.


assignment:
`````````````
write one program on Object class methods(11 methods)



note:
````
difference between this() and super()?

 this()or this(..) 
  
   ->refering current class default or parameterized constructor(s)
  
 super() or super(..)
 
   ->refering parent class default or parameterized constructor(s)
   
 super.<variablename>
   ->refering parent class variable 
   
 super.methodname()
  
   ->refering parent class method.
   
 
 
 
 
 
 polymorphism:
``````````````
it is the process of defining one action into many forms.

  types of polymorphism
  
   
   -compile time polymorphism
   
     -this polymorphism can be decided at compiletime by the java compiler
	 -when we call the method , method call is binded to which method will 
	  be decided at compiletime by the java compiler based on the reference 
	  variable.
	  
	  
	  
	  
   -runtime polymorphism
   
   
in java, how we can achieve this polymorphism?

  we have two concepts 
  
   1.method overloading
   2.method overriding
   
   
method overloading:
 
   method name is same
   but signature is different
   
    -type of parametrs
	-no.of parameters
	-atleast order of parameters
	
	
advantages of method overloading:
`````````````````````````````````
1.it improves the readability of written code
2.it adds cleanliness to the code written
3.it can be used on constructors also so that we can 
  create different objects by passing different data.
  
  
  note:
  to achieve method overloading , one class is more than enough.
  
  
note:
by changing returntype can we perform method overloading?

no, only by changing signature.


example:
````````
//example for method overloading cum compiletime polymorphism
public class Test8 {
	
	public void sum(int x, int y)
	{
		System.out.println("Integer sum: " + (x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum: " + (x+y));
	}

	public static void main(String[] args) {
		//objcet declaration at compiletime
		Test8 obj;
	    //object creation at runtime	
		obj=new Test8();
		
		obj.sum(2, 3);
		obj.sum(4.5,4.5);
		
	}
}

note:
`````
we can achieve the method overloading using object reference 
variable. 


method overriding:
``````````````````
-method name is same
-but logic is different from parent class to child class.

note:
to achieve method overriding minimum we require 
two classe(s) with parent-child realtion.


why should we go for method overriding?
```````````````````````````````````````
we have already parent class method has some logic
if we don't require or if we want to provide some new logic 
then we can go for method overriding.

Object 
  -toString()
  -className@HashCode
  
  
rules for method overriding:

 1.method must have the same name as in the parent class.
 2.method must have the same parameter as in the parent class.
 3.there must be an is-a realtionship.
 4.@Override annotation is recommended while we are overriding.
 
 
Parent.java:
````````````

public class Parent {

	public void sum()
	{
		System.out.println("sum-parent");
	}
	
}

Child.java:
````````````
public class Child extends Parent {

	@Override
	public void sum()
	{
		System.out.println("sum-child");
		//call the super class method
		super.sum();
	}
}

Test7.java:
````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		//Child obj = new Child();
		//Parent obj = new Parent();
		Parent obj=new Child();
		//Child obj =new Parent();
		obj.sum();
		
	}
}


note:
`````
based on the object type which method will be associated with 
which method that will be decided is called as 
runtime polymorphism.

based on the object reference varaible it is not possible.


static methods are not participating in method overriding.


note:
`````
while we are overriding we are allowed to increase the scope of the 
property not possible to decrease the scope of the property.

  private -> default -> protected ->public 

  
private properties are not eligible for method overriding, since private
properties only we are able to access within the class not from outside 
the classe(s).


final methods/properties are not eligile for method overriding, since 
final properties are constants ,  modifications are not possible.




String class api in java:
``````````````````````````
String is a predefined class available in java.lang package.

purpose: to store the series of characters.


in how many ways we can create the String object 

 -> two ways
 
 1.using String literal
 2.using new keyword
 
 
 
 String s1 = "Rama";(it gets stored inside scp memory area which is the part of 
 heap memory area which is the part of jvm which is the part of ram)
 
 
 String s2 = new String("Rama");
 (it gets stored inside heap memory area )
 
 
 note:
 `````
  scp memory area will not allow duplicates
  
  where as heap memory always creates new object irrespective
  of whether it is same or different.
  
  
 
String s1 = new String("rama");
String s2 = new String("rama");

 

String class object is immutable in nature.


unmodifiable 


->once we create any String object, on top of existing String object 
we could not perform any manipulations/modifications 

how to compare the String:
``````````````````````````
 ->by using == operator(Reference comparision operator)
 ->by using equals() or equalsIgnoreCase()
 ->by using compareTo() or compareTOIgnoreCase()
     -compareTo() compares Strings based on lexigraphical comparision.
	 -based on unicode values.
	 
	 
example:
````````
//program on string comparisions -different ways 

public class Test5 {
	
	public static void main(String[] args) {
		
		//string literal approach -it won't allow duplicates
		String s1 = "rama";
		String s2 = "rama";
		String s5 = "Rama";

		//to find out unicode value of character based on the index
		System.out.println(s1.codePointAt(0));
		System.out.println(s5.codePointAt(0));
		
		
		System.out.println(s1==s2);//true
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s5));//false
		System.out.println(s1.equalsIgnoreCase(s5));//true
		System.out.println(s1.compareTo(s2));//0
		System.out.println(s1.compareTo(s5));//32
		System.out.println(s5.compareTo(s1));//-32
		System.out.println(s1.compareToIgnoreCase(s5));//0
		
		//using new keyword -it creates everytime as a new object
		String s3 = new String("hyd");
		String s4 = new String("hyd");
		
		System.out.println(s3==s4);//false
		System.out.println(s3.equals(s4));//true
		
	}

}

 
checking immutability vs mutablity using String,StringBuffer and StringBuilder:


public class Test6 {

	public static void main(String[] args) {
		
		//immutable object
	 String s1 = "Rama";
	 s1.concat("hyd");
	 System.out.println(s1);//Rama
	   //mutable object
	 StringBuffer s2 = new StringBuffer("Rama");
	 s2.append("hyd");
	 System.out.println(s2);//Ramahyd
	  //mutable object
	 StringBuilder s3 = new StringBuilder("Rama");
	 s3.append("hyd");
	 System.out.println(s3);//Ramahyd

	}
}


note:
using StringBuffer & StringBuilder we can create mutable Strings but 
differnce is StringBuffer methods are synchrnozed(thread safe) methods where as
StringBuilder methods are non-synchrnized(not thread safe) methods.

example on frequently used methods of String class:
````````````````````````````````````````````````````

public class Test6 {

	public static void main(String[] args) {
		
		String s1 = new String("Rama");
		String s3= new String("Rama");
		String s4 = new String("Rama,hyd,software,hardware");	
		String s2 = "  banga  lore   ";
		int value=40;
		String s5 = String.valueOf(value);
		
		String str = new String("welcome to java sessions");
	
		System.out.println("length of the stirng: " + s1.length());
		
		System.out.println("character at 0th position: " + s1.charAt(0));//R
		
		System.out.println(s1.concat("hyd"));//Ramahyd
		
		System.out.println(s1.contains("R"));//true
		System.out.println(s1.contains("j"));//false
		
		System.out.println(s1.endsWith("j"));
		System.out.println(s2.indent(2));//  banga  lore
		System.out.println(s2.indent(-2));//banga  lore
		System.out.println(s2.indent(0));//  banga  lore	
		System.out.println(s1.intern()==s3.intern());//true
		System.out.println(s1.substring(1));//ama
		System.out.println(s1.substring(0, 3));//Ram
		String[] split = s4.split(",");
		for(String s:split)
		{
			System.out.println(s);
		}
		
		System.out.println(s5+10);
		System.out.println(s2.length());
        System.out.println(s2.strip().length());
        
        System.out.println(str.matches("welcome(.*)"));
        System.out.println(str.matches("tutorials"));
 
	}
}
















abstraction:
````````````
  -security
  -enhancements
  -manitability
  -modularity
  
 
hiding the implementation details and showing only services to the end users.
  
abstraction is also one of the oop principle.

   -abstract classe(s)(partial abstraction)
   -interface
   

abstract class:
````````````````
 ->concrete classes (fully defined classes)
 ->abstract class 
 
 abstract class is a combination of both 
 defined methods 
 and as well as undefined methods
 
 undefined method/abstract method:
   
     public abstract void getRateOfInterest();->method declaration
	 
	 
	 
note:

  if a class contains atleast one abstract method it is highly 
mandatory to make corresponding class also as 
abstract class using abstract keyword before the class declaration.



    abstract class Test{
    public abstract void m1();
	public void m2(){}
	
	public Test()
	{
	}
	}

  
 for a single abstract class, how many implementation classe(s) we can define?
 
 as many as you want.

 
  class Test1 extends Test
  {
    public void m1(){}
	
	public Test1()
	{
	  super();
	}
  }


  Test obj = new Test1();
  
  obj.m1();
 

in abstract class, can we define constructor(s)?
yes

Bank.java:
```````````


abstract public class Bank {

	 abstract int getRateOfInterest();
}

SBI.java:
``````````

public class SBI extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5;
	}

}

CityBank.java:
```````````````

public class CityBank extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7;
	}

}



TestBank.java:
``````````````

public class TestBank {
public static void main(String[] args) {
	
	Bank b ;
	b=new SBI();
	System.out.println("sbi bank rate of interest is : " + b.getRateOfInterest());
	
	b =new CityBank();
	System.out.println("city bank rate of interest is : " + b.getRateOfInterest());
}
}


example on abstract class with constructor:
````````````````````````````````````````````

abstract public class Bike {
	
	Bike()
	{
		System.out.println("bike is created");
	}

	void changeGear()
	{
		System.out.println("gear changed");
	}
	
	abstract void run();
}


Honda.java:
````````````

public class Honda extends Bike {

	@Override
	void run() {
		
		System.out.println("running safely...");

	}

}

TestAbstraction.java:
`````````````````````
public class TestAbstraction {
public static void main(String[] args) {
	
	
	Bike obj = new Honda();
	obj.run();
	obj.changeGear();
}
}




interface:
``````````

interface
implemetnatin class
execution logic class



interface i1
{
  public abstract void m1();
  public static final int x=100;
}

note:
by default interface methods are public abstract 
and by default interface datamembers are public static final.


 extends: 
 
 using extends keyword we can take the properties from 
 class to class and interface to interface (homogenious)
 
 implements:
 
 using implements keyword we can take the properties from 
 interface to class(heterogenious)
 
 assignment:
 do one program on top of interface
 
interface inheritance and multiple inheritance:
```````````````````````````````````````````````

public interface i1 {
	
	void m1();

}


i2.java:
`````````

public interface i2 {
void m2();
}


Test9.java:
```````````

public class Test9 implements i1,i2{

	@Override
	public void m1() {
		System.out.println("m2 body");

	}

	@Override
	public void m1() {
		System.out.println("m1 body");

	}
	
	public static void main(String[] args) {
     	i2 obj;
		obj = new Test9();
		obj.m1();
		obj.m2();
	
	}

}

encapsulation:
``````````````

encapsulation = datahiding + abstraction

encapsulated class:

 class is the best example for an encapsulation.
 
 by declaring datamembers as private 
 and by defnining public setters and getter methods(s).
 
 
Student.java:
``````````````

public class Student {

	//data hiding
	private int stid;
	private String stname;
	
	//abstraction 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	
}
Test10.java:
````````````

public class Test10 {
	
	public static void main(String[] args) {
		Student student = new Student();
		
		student.setStid(100);
		student.setStname("Rama");
		
		System.out.println("student id: " + student.getStid());
		System.out.println("student name: " + student.getStname());
		
	}

}




exception handling :
 ``````````````````
 
 erros are of two types
   
    ->compiletime errors->poor in syntaxes
	->runtime errors-> when we pass invalid input
	
	            ->100/20 ->5
				->100/0 ->java.lang.ArithmeticException: /by zero 
 
   exceptions
   
   
 drawbacks of exceptions:
 ````````````````````````
 ->control terminates abnormally
 
 --
 -- int x = 100/0;
 --
 1000
 
 ->we are not able to maintain normal flow of execution 
 ->if exception occurs , we will get system error messages
   which are not understable by end user which is not 
   recommended.
   
   
 we have to handle the exception
 
  how can we handle the exceptions?
  
     ->try
	 ->catch
	 ->finally
	 ->throws
	 ->throw
	 
	 
 types of exceptions:
 
   ->pre-defined exceptions
   ->user-defined exceptions
   
 

java.lang.Object
 
      Throwable

Error       Exception 


 ->pre-defined exceptions
  
     ->asynchronous exceptions ->if any hardware related issues
	 
	   java.lang.OutOfMemoryException,stackOverFlow ...
	   
	 ->synchronous exceptions->if any programatical errors
	 
	            ->checked exceptions->ex: SQLException,IOException,...
				->unchecked exceptions-> RuntimeException
				
 
 
   hallticket -> HallTicketNotFoundException
   
   pen -> PenNotFoundException
   
   BombBlastException
   
 
 -predefined exceptions for to handle universal problems.
 
 
   jvm internally throws a particular/specific exception
   
   
 
 without handling the exception:
 ``````````````````````````````
 package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
		
		System.out.println("division is: " + z);
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
	}

}


try:
````
try block is used to keep 

 ->problematic statements which causes problems at runtime.
 
 syntax:
   
     try
	 {
	   //problematic statements
	 }
 

catch block:
`````````````
 ->to catch the exception
 
 syntax:
 
   catch(<exceptionclassname> <referencevariablename>)
   {
    //user friendly message
   }
   
note:
while we are handling the exceptions, we should always follows the order
which is from  specific to general otherwise we will get compile time error
saying that unreachable code for the java compiler.

example:
`````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
	     	System.out.println("division is: " + z);
		}
		
		
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		catch(NumberFormatException nfe)
		{
			System.out.println("please pass only numerics");
		}
		
		catch(ArrayIndexOutOfBoundsException ai)
		{
			System.out.println("please supply the input");
		}
	
		catch(RuntimeException re)
		{
			System.out.println(re);
			
		}
		
		
		
		System.out.println("Rest of the statements  executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
		
		
	}

}









nested try block:
`````````````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			
			try {
				System.out.println("divide by 0");
				int x = 40/0;
			}
			catch(ArithmeticException ae)
			{
				System.out.println(ae);
			}
			
			try {
				int x[] = new int[5];
				x[5]=4;	
			}
			
			catch(ArrayIndexOutOfBoundsException ai)
			{
				System.out.println(ai);
			}
			
			System.out.println("other statements");
		}
		//catch block of outer try block
		
		catch(Exception e)
		{
			System.out.println("handled the exceptions");
		}
		
		System.out.println("Normal flow");
		
	}

}


finally block:
``````````````

it is used to release the resources
recommended to keep closing logic(closing files,closing db connections)
--
--
--
--
 open the file
 
 ..
 ... raises an exception 
 ..
 ..
 finally{
    close the file
 }
 

package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}
		
		
		finally
		{
			System.out.println("Finally block executed");
		}
		System.out.println("Normal flow");
		
	}

}

finally block always executed whether exception occurs or not?
note:
we are writing the finally block is for keeping closing related logic
or to close the resources.

 like conneciton closing logic, closing the file objects etc.. to escape
 from memory leakage problem or data leakage problem(s).
 
 
->try with finally block is possible
->exclusive only finally block is not possible.
->try ,catch and finally blcoks is possible
->in between try and catch is it possible to write finally block ->no
->nested try block with finally also possible.

 

   


throws:
```````

throws keyword gives an indication to the calling fucntion to keep 
called function under try and catch block.






//called
class Test{
 void div() throws ArithmeticException
 {//ae}
 }

//calling 
class Demo{
  Test ob = new Test();
  try{
  obj.div();
  }
  catch(AE ae){
  }
}


parseInt()

sleep() throws InterruptedException 

Test1.java:
```````````
package com.citus.exceptions;
//called program
public class Test1 {
	
	public void div() throws ArithmeticException
	{
		int x=100/0;
		
	}

}


Test2.java:
```````````
package com.citus.exceptions;
//calling program
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		try {
		obj.div();
		}
		catch(ArithmeticException ae)
		{
			System.out.println(ae);
		}
		System.out.println("Rest of the statements");
		
	}

}

throw:
``````
throw is a java reserved keyword which is used to throw an exception explictly.

 int x = 100/0;
 
    ArithmeticException ae = new ArithmeticException();
	








note:
we are using this throw keyword to throw a user defined exception explictly 
not for pre-defined execption.


syntax:

   throw new <exceptionclassname>();
  


  
note:
every exception internally it is a class.


example:
````````
package com.citus.exceptions;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		String str = "rama";
		if(str.startsWith("r"))
		{
			try {
			    throw new ArithmeticException();
			}
			catch(ArithmeticException ae)
			{
				System.out.println("String is invalid");
			}
		}
		else
		{
			System.out.println("String is valid");
		}
		
		
	}

}


user defined exceptions using throw keyword:
``````````````````````````````````````````````
package com.citus.exceptions;

public class Test3 {
	
	public void checkProduct(int weight) {
		if(weight>=100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ipe)
			{
				System.out.println("product weight must be greater than 100kgs");
			}
		}
		
	}
	public static void main(String[] args) {
		
		Test3 obj = new Test3();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
class InvalidProductException extends Exception 
{
}

note:
`````
to make normal java class as an exception class, make sure that class must be
extending from Exception/RuntimeException/Throwable class.


exception handling with method overriding:
```````````````````````````````````````````
.if the superclass method doesnot declare an exception,sub class overriden 
 method cannot declare the checked exception but it can declare unchecked
 exception.
 
   class Parent{
      public void m1(){}
	  }
	  class Child extends Parent
	  {
	     public void m1() throws ArithmeticException
		 
		 {}
	  }
	  class Child extends Parent
	  {
	     public void m1() throws IOException
		 
		 {}
	  }
 
.if the superclass method declares an exception, sub class overriden method 
can declare same,subclass exception or no exception but cannot declare 
parent exception.
     sum() throws RuntimeException{}
	 
	 sum()throws RuntimeException{}

     sum() 
	 
	 sum() throws ArithmeticException
	 
	 sum() throws Throwable-invalid

	 
	 
	 

example for exception propagation:
``````````````````````````````````
package com.citus.exceptions;


public class Test4 {
	
	void m()
	{
		int x=7/0;
	}
	void n()
	{
		m();
	}
	void p()
	{
		try {
		n();
		}
		catch(Exception e)
		{
			System.out.println("exception handled");
		}
	}
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.p();
		System.out.println("normal flow");
	}

}

note:
````
an exception is first thrown from the top of the stack and if it is not caught,
it drops down to the call stack to the previous method.
if not caught there,the exception again drops down to the call stack to the 
previous method , and so on until they are caught or until they reach 
the very bottom of the call stack 

This is called exception propagation.
 

note:
``````
while we are handling the exceptions, we should follow the order

order is from specific to general not from 
general to specific otherwise we will get compile time error
saying that unreachable catch blocks by the java compiler.





java Arrays:
````````````
array is a collection of homogenious data.

 int x=100;
 int x[] = {200,100};
 

syntaxes:

 datatype[] arr;
 datatype []arr;
 datatype arr[];
 
instantiation of an array:
<arrayreferencevariable> = new datatype[size];


example:
`````````

public class Test7 {

	public static void main(String[] args) {
		
		//declaration cum instantiation
		int a[] = new int[3];
		//initialization
		a[0]=100;
		a[1]=200;
		a[2]=300;
		
		//int a[]= {100,200,300};
		//traversing an array using for loop
		
		for(int i=0;i<a.length;i++)
		{
			System.out.println(a[i]);
		}
		System.out.println("=============");
		
		//traversing an array using for each loop
		
		for(int b:a)
		{
			System.out.println(b);
		}
	}
}


example on anonymous array:
````````````````````````````

public class Test7 {

	static void printArray(int arr[])
	{
		for(int i=0;i<arr.length;i++)
			System.out.println(arr[i]);
	}
	public static void main(String[] args) {
		
		printArray(new int[]{100,200,300});
		
	}
}

example on returning array from a method:
``````````````````````````````````````````

public class Test7 {

	static int[] get()
	{
		return new int[]{100,200,300};
	}
	public static void main(String[] args) {
		
		int arr[]=get();
		//print the array data
		
		for(int a:arr)
		{
			System.out.println(a);
		}
	}
}



multidimensional array:
```````````````````````
datatype referncevariable[][];

int[][] arr = new int[3][3];

example:
`````````


public class Test7 {

	public static void main(String[] args) {
		
		int arr[][]= {{1,2,3},{4,5,6},{7,8,9}};
		int x[]= {1,2,3};
		for(int i=0;i<3;i++) {
			for(int j=0;j<3;j++)
			{
				System.out.print(arr[i][j] + " ");
				 
			}
			System.out.println();
			
			System.out.println(arr.getClass().getName());
		    System.out.println(x.getClass().getName());
		}
	}
}


//assigment:
write a program for cloning an array?

write a program for addition of two matrices?

Collection framework:
``````````````````````

Collection:
```````````

note:
 to work with collecton api, make sure we have to import java.util pacakge
 
 2 types
 
   1dcfw - either in the form of row or column
   2dcfw -(key,value) pair
   

interface(s):
`````````````
                       Collection
 List                  Set             Queue
 
                       SortedSet
 


note:
`````
 for Collection interface, they didn't provide any direct implementation class.
 but Collection interface is acting root interface for all 1dcfw interface(s).
 since it contains some common methods which will be useful for all Collection(S)
 in java like adding, removing,clearing,checking,finding the size etc...


 
List:
``````
 List extends Collection
 
 -it contains Collection and List method(s).
 
 for List interface what are the implementation classe(s)?
 
    ArrayList
	LinkedList
	 -
	Vector
	Stack
    ..legacy classe(s)


when should we go for List?

  -it allows both homogenious and heterogenious element(s)/object(s)
  -duplicate elements are allowed
  -insertion order is preserved
  -null insertion is possible
  

note:
Collections support only object type(s) even though if we pass primitive 
values internally from jdk1.5 version onwards java compiler converts
primitive to object type and viceversa.

 primitive to object type - autoboxing
 object type to primitive - autounboxing.
 
 
 
 
 
note:
for-each loop we can apply on top of two elements
  -one is array
  -collection variable
  
  Iterable interface
  

example:
`````````
package com.citus.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		//create the object of List interface
		
		List<Integer> l = new ArrayList();
		
		/*
		 * l.add("rama"); l.add(100); l.add(true); l.add(3.4); l.add(100); l.add(null);
		 * l.add(null);
		 */
		
		for(int i=1;i<=10;i++) {
			l.add(i);
		}
		
		
		
		System.out.println(l);//[rama, 100, true, 3.4, 100, null, null]
		
		System.out.println("size is: " + l.size());//7
		
		System.out.println("element at 0th index: " + l.get(0));//rama
		
		
		System.out.println("======using for loop===========");
		
		for(int i=0;i<l.size();i++)
		{
			System.out.println(l.get(i));
		}
		
		System.out.println("======using foreach loop===========");
		
		for(Integer temp:l)
		{
			if(temp%2==0) {
				System.out.println(temp);
			}
		}

	}
}


what is the difference between ArrayList and LinkedList?
``````````````````````````````````````````````````````````
->dynamic array
->doubly linkedlist


note:
if our frequent operation is accessing then we will go for ArrayList.

note:
if our frequent operation is manipulation then we will go for 
LinkedList

 
do the program on top of Vector and stack?


Set:
`````
->it allows both homogenious and heterogenious elements
->duplicates are not allowed
->insertion order is not preserved
->null insertion is possible only once.

           HashSet
           LinkedHashSet
		   
difference between HashSet and LinkedHashSet:

  HashSet doesn't follow insertion order whereas incase of LinkedHashSet it 
  follows insertion order is preserved.
  
  
example:
`````````
package com.citus.cfw;

import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

public class Test2 {
	
	public static void main(String[] args) {
		//generics
		Set<Student> s = new LinkedHashSet();
		
		Student st1 = new Student();
		st1.setStid(100);
		st1.setStname("anusha");
		
		Student st2 = new Student();
		st2.setStid(101);
		st2.setStname("Rishi");
		
		s.add(st1);
		s.add(st2);
		
		
		System.out.println("size is: " + s.size());
		
		for(Student st:s)
		{
			if(st.getStname().startsWith("a"))
				System.out.println(st.getStname());
		}
	}

}

Student.java:
`````````````
package com.citus.cfw;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	public Student() {
		super();
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	

}


 note:
 Set is the sub interface of Collection 
 
  Set doesn't have any specific methods 
  

SortedSet:
```````````
 SortedSet is also an interface extends Set extends Collection extends Iterable
 

                  TreeSet
				  

->it allows only homogenious elements
->insertion order is sorted(default sorting technique-ascending/alphabetical)
->null insrtion is not possible even for once
->TreeSet has some specific methods(headSet(),tailSet(),subSet(),first(),last())


				  
example:
``````````
package com.citus.cfw;


import java.util.TreeSet;

import java.util.Comparator;

class MyComparator implements Comparator<Integer>
{

	@Override
	public int compare(Integer o1, Integer o2) {
		
		return -o1.compareTo(o2);
	}
	
}
public class Test3 {
	
	public static void main(String[] args) {
		
		TreeSet<Integer> ts = new TreeSet<Integer>(new MyComparator());
		
		
		ts.add(100);
		ts.add(34);
		ts.add(67);
		ts.add(675);
		ts.add(-8);
	
		  System.out.println(ts.first());//-8 System.out.println(ts.last());//675
		  System.out.println(ts.headSet(67));//[-8, 34]
		  System.out.println(ts.tailSet(67));//[67, 100, 675]
		  System.out.println(ts.subSet(100, 34));//[34, 67]
		 			
		System.out.println(ts);
		
	}

}


adding userdefined object to the TreeSet:
```````````````````````````````````````````
package com.citus.cfw;


import java.util.TreeSet;

import java.util.Comparator;

class StudentNameComparator implements Comparator<Student>
{

	@Override
	public int compare(Student o1, Student o2) {
		
		return -o1.getStname().compareTo(o2.getStname());
	}
	
}
public class Test3 {
	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<Student>(new StudentNameComparator());
		
		Student s1 = new Student();
		s1.setStid(100);
		s1.setStname("rama");
		
		Student s2 = new Student();
		s2.setStid(101);
		s2.setStname("hyd");
		
		ts.add(s1);
		ts.add(s2);
		
		System.out.println(ts);
		
	}

}


do the one program on top of Queue interface?

 
cursors in java:

 to iterate the collection data one by one 
 
 

  -Enumeration -> on legacy classe(s)
  -Iterator
  -ListIterator
  
  

Iterator:
```````````
it is an interface available in java.util package 

iterator()

 Iterator itr = <anycollectionclassobject>.iterator();
 sysout(itr.getClass().getName());
 
Iterator example:
`````````````````
package com.citus.cfw;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class Test1 {
	
	public static void main(String[] args) {
		
		//create the object of List interface
		
		List<Integer> l = new LinkedList();
		
		
		
		for(int i=1;i<=10;i++) {
			l.add(i);
		}
		
	 Iterator<Integer> itr = l.iterator();
	 
	 while(itr.hasNext())
	 {
		 int x = itr.next();
		 if(x%2==0)
		 {
			 System.out.println(x);
		 }
		 else
		 {
			 itr.remove();
		 }
	 }
	
	 
	 System.out.println(l);//[2,4,6,8]
	}
	

}


note:
Iterator is the universal cursor 
-it can be applicable on top of any collection class.
-it is unidirectional cursor
-using this we can remove the object based on the condition

ListIterator:
`````````````
note:
this interface we can apply on top of only List realted implementation classes.

-it is bidirectional cursor.

  inboth forward direction and backward direction 
  add the elements
  update the elements
  remove the elements
  

example:
`````````
package com.citus.cfw;

import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

public class Test1 {
	
	public static void main(String[] args) {
		
		//create the object of List interface
		
		List<Integer> l = new LinkedList();
		
		for(int i=1;i<=10;i++) {
			l.add(i);
		}
		
		//create the object of ListIterator
		
		ListIterator<Integer> ltr = l.listIterator();
	 
	     System.out.println("displaying the elements in forward direction ");
	     
	     
	     while(ltr.hasNext())
	     {
	    	 System.out.println(ltr.next());
	    	 
	     }
	     
	     System.out.println("displaying the elements in backward direction");
	     
	     while(ltr.hasPrevious())
	     {
	    	 System.out.println(ltr.previous());
	     }
	     
	     
	}
     

}





2dcfw:
`````
to organize the data in the form of (key,value) pair.

key ->object ->unique 
value-> object->value can be duplicated

  java.util.Map
  
   HashMap
   LinkedHashMap
   
  
   
  java.util.SortedMap->TreeMap


HashMap allows both homogenious and heterogenious data.
insertion order is not preserved
null insertion is possible
duplicates are allowed for value objects but not allowed for keys



HashMap:
````````
package com.citus.cfw;

import java.util.HashMap;
import java.util.Map;

public class Test4 {
	
	public static void main(String[] args) {
		
		
		Map m = new HashMap();
		m.put(100, "sourabh");
		m.put(101,"amith");
		m.put(102, "trupti");
		m.put("anusha", 200);
		m.put(100, "raj");
		m.put(null, null);
		m.put(null, "rama");
		m.put(300,null);
		
		
		
		
		System.out.println(m);
		
		System.out.println("size is : " + m.size());//6
		
		System.out.println(m.remove(300));//null
		System.out.println("size is : " + m.size());//5
		System.out.println(m.remove(150));//null
		
		System.out.println(m.get(102));//trupti
		
		System.out.println(m.get(202));//null
		
		System.out.println(m.keySet());//[]
		System.out.println(m.values());//[]
		
		
		
		
	}

}


example:
````````
package com.citus.cfw;

import java.util.HashMap;
import java.util.Map;

public class Test4 {

	public static void main(String[] args) {

		Map<Integer, String> m = new HashMap();
		m.put(230, "rama");
		m.put(100, "sourabh");
		m.put(101, "amith");
		m.put(102, "trupti");

		for (Map.Entry<Integer, String> m1 : m.entrySet()) {
			System.out.println(m1.getKey() + " " + m1.getValue());
		}

	}

}



TreeMap:
````````
TreeMap allows only homogenious elements
null insertion is not possible
insertion order is preserved(default natural sorting order: 
ascending/alphabetical)
duplicates are not allowed

inside TreeMap, we can find few new methods like TreeSet methods
 
   -firstKey(),lastKey(),headMap(),subMap(),tailMap()...
   
example:
````````
package com.citus.cfw;

import java.util.Comparator;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

class MyComparator implements Comparator<Integer>
{

	@Override
	public int compare(Integer o1, Integer o2) {
		return -o1.compareTo(o2);
	}
	
	
}
public class Test4 {

	public static void main(String[] args) {

		SortedMap<Integer, String> m = new TreeMap(new MyComparator());
		m.put(230, "rama");
		m.put(100, "sourabh");
		m.put(101, "amith");
		m.put(102, "trupti");
		m.put(75, "sruthi");
		m.put(66, "charviha");
		System.out.println(m);//{66=charviha, 75=sruthi, 100=sourabh, 101=amith, 102=trupti, 230=rama}

		
	}

}
 
 


ClientTest.java:
````````````````
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import com.infotech.model.Department;
import com.infotech.model.Employee;

public class ClientTest {

	public static void main(String[] args) {
		
		Employee e1 = new Employee(1009, "Sam", 90000.00, "sam@infotech.com");
		Employee e2 = new Employee(2009, "Ambay", 30000.00, "martin@infotech.com");
		Employee e3 = new Employee(3009, "Joya", 50000.00, "joya@infotech.com");
		Employee e4 = new Employee(4009, "Boya", 70000.00, "harry@infotech.com");
		Employee e5 = new Employee(5009, "Sean", 80000.00, "sean@infotech.com");
		
		Employee e6 = new Employee(5010, "Abrahim", 930000.00, "abrahim@infotech.com");
		
		
		Department d1 = new Department(10001, "IT", "Boston");
		Department d2 = new Department(10002, "Finance", "Chennai");
		
	   // Map<Employee,Department> empDeptMap = new HashMap<>();
		Map<Employee,Department> empDeptMap = new ConcurrentHashMap<>();
		
		empDeptMap.put(e1, d1);
		empDeptMap.put(e2, d1);
		empDeptMap.put(e3, d1);
		
		empDeptMap.put(e4, d2);
		empDeptMap.put(e5, d2);
		
		//empDeptMap.put(null, d1);
		//empDeptMap.put(e6, null);
		
		Set<Entry<Employee, Department>> entrySet = empDeptMap.entrySet();
		Iterator<Entry<Employee, Department>> iterator = entrySet.iterator();
		
		while (iterator.hasNext()) {
			Map.Entry<Employee, Department> entry = (Map.Entry<Employee,Department>) iterator.next();
			Employee employee = entry.getKey();
			Department department = entry.getValue();
			System.out.println(employee);
			System.out.println(department);
			empDeptMap.put(e6, d2);
		}
	}
}

Department.java
````````````````
public class Department {

	private Integer deptId;
	private String deptName;
	private String deptLocation;
	
	public Department(Integer deptId, String deptName, String deptLocation) {
		super();
		this.deptId = deptId;
		this.deptName = deptName;
		this.deptLocation = deptLocation;
	}
	@Override
	public String toString() {
		return "Department [deptId=" + deptId + ", deptName=" + deptName + ", deptLocation=" + deptLocation + "]";
	}
}
Employee.java:
```````````````
public class Employee{

	private Integer employeeId;
	private String employeeName;
	private Double salary;
	private String email;
	
	public Employee(Integer employeeId, String employeeName, Double salary, String email) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.salary = salary;
		this.email = email;
	}
	

	public Integer getEmployeeId() {
		return employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public Double getSalary() {
		return salary;
	}

	public String getEmail() {
		return email;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((email == null) ? 0 : email.hashCode());
		result = prime * result + ((employeeId == null) ? 0 : employeeId.hashCode());
		result = prime * result + ((employeeName == null) ? 0 : employeeName.hashCode());
		result = prime * result + ((salary == null) ? 0 : salary.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (email == null) {
			if (other.email != null)
				return false;
		} else if (!email.equals(other.email))
			return false;
		if (employeeId == null) {
			if (other.employeeId != null)
				return false;
		} else if (!employeeId.equals(other.employeeId))
			return false;
		if (employeeName == null) {
			if (other.employeeName != null)
				return false;
		} else if (!employeeName.equals(other.employeeName))
			return false;
		if (salary == null) {
			if (other.salary != null)
				return false;
		} else if (!salary.equals(other.salary))
			return false;
		return true;
	}


	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", salary=" + salary
				+ ", email=" + email + "]";
	}
}




     the default implementation is not enough to satisfy business needs.
	 
	 
	 note:
	 if two objects are equal according to the equals() of Object class,
	 then calling the hashCode() on each of the two objects must produce
	 the same integer result.
	 

Student.java:
````````````
package com.citus.cfw;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	public Student() {
		super();
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + stid;
		result = prime * result + ((stname == null) ? 0 : stname.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (stid != other.stid)
			return false;
		if (stname == null) {
			if (other.stname != null)
				return false;
		} else if (!stname.equals(other.stname))
			return false;
		return true;
	}

	
	
	

}


Test.java:
```````````
package com.citus.cfw;

import java.util.HashSet;

public class Test {
	
	public static void main(String[] args) {
		
		Student s1 = new Student(100,"ram");
		Student s2 = new Student(100,"ram");
	
		/*
		 * System.out.println(s1.equals(s2));//true
		 * 
		 * System.out.println(s1.hashCode()); System.out.println(s2.hashCode());
		 */
		
		  HashSet<Student> hs = new HashSet<Student>();
		  
		  hs.add(s1); 
		  hs.add(s2);
		  
		  System.out.println(hs.size());
		  System.out.println(hs);
		 
		
	}

}

	 




java Regex:
``````````````
Regular expression is an API to define 
a partern for searching or manipulating strings.

it is widely used to define the constraint on strings
such as password validation or email validation.


1.MatchResult interface

2.Matcher class

3.Pattern class

4.PatternSyntaxException class


Charcater class:

[abc]-a or b or c 

[^abc]

[a-zA-Z]


Regex Quantifiers:
````````````````````
quantifiers specify the number of occurances of a character.

x? ->x occurs once or not at all.

x+ -> x occurs once or more times

x* -> x occurs zero or more times

x{n}-> x occurs n times only

x{n,}->x occurs n or more times
x{y,z} -> x occurs at least y times but less than z times.



Regex Metacharacters:
```````````````````````
. -> any character
\d -> any digits [0-9]
\D -> any non-digit [^0-9]
\s -> any whitespace characer [\t\n]
\S -> any non white space character  [^\s]

\w -> any word character [a-zA-Z]


example:
````````
package com.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test1 {
	
	public static void main(String[] args) {
		
		Pattern p = Pattern.compile(".s");//. represents single character
	
	    Matcher m = p.matcher("s");
	    
	    boolean b1 = m.matches();
	    
	    
	    boolean b2 = Pattern.compile(".s").matcher("as").matches();
	    System.out.println(b1);
	    
	    System.out.println(b2);
	    
	    //boolean b3 = Pattern.matches(".s", "as");
	    System.out.println(Pattern.matches(".s", "as"));
	    System.out.println(Pattern.matches("..s","mas"));
	    System.out.println(Pattern.matches("[amn]","ammmna"));
	    
	    System.out.println(Pattern.matches("[amn]?", "a"));
	    
	    System.out.println(Pattern.matches("[amn]+", "aazzzttt"));
	    
	    System.out.println(Pattern.matches("[amn]*", ""));
	    
	    System.out.println(Pattern.matches("\\d", "1abc"));
	    System.out.println(Pattern.matches("\\D*", "abc"));
	    
	    
	    System.out.println(Pattern.matches("[a-zA-Z0-9]*", "rama88"));
	    
	    System.out.println(Pattern.matches("[789]{1}[0-9]{9}", "8500122392"));
	    
	    System.out.println(Pattern.matches("[789]{1}\\d{9}", "8500122392"));
	    
	    
	}

}



Java 11 Beyond Basics
`````````````````````

lamda expression:
 ````````````````
 the main objective of lamda expression is to bring benefits of 
 functional programming in java.
 
 
 
 lamdba expression is just a nameless(anonymous) function

   function doesn't have name,returntype and access modifiers.
   
   lambda expression --> anonymous functions or closures.
   
   
  eg:
  
    public void m1()
	{
	Sysout("hello");
	}


     
	 ()->System.out.println("hello")
	 
	

	
  eg:
    public void add(int a, int b){
	  sysout(a+b);
	}
	
	

   (a,b)->System.out.println(a+b);


  eg:
  
    public String str(String str)
	{
	 return str;
	}

  (String str) -> return str;
  
  (str)->str;
  
  
1.A lambda expression can have zero or more number of arguments.


functional interface:
`````````````````````
if an interface contains only one abstract method, such type of interfaces
are called functional interfaces and the method is called functional method
or single abstract method(sam).



eg:
Runnable  ->run()
Comparable-->compareTo()
ActionListener
...

from java8 inside interface we also can define default and static methods.

along with these sam based on requirement if we want to keep these default
and static methods 
  yes we can keep it.


functional interface should contain only one abstract method.

eg:
 @FunctionalInterface
 interface interf1
  {
   public abstract void m1();
   default void m2(){
   }
  }
  
example:
```````
package com.capg.jse.lamdaexpressions;

@FunctionalInterface
interface Interf
{
	public void m1();
	
}

public class Test1
{
	public static void main(String[] args) {
		
		Interf i = ()->System.out.println("method one");
		
		//calling the method
		i.m1();
		
		
}
}




example:
`````````
package com.capg.jse.lamdaexpressions;

@FunctionalInterface
interface Interf
{
	public void sum(int a, int b);
	
}

public class Test1
{
	public static void main(String[] args) {
		Interf i = (a,b)->System.out.println(a+b);
		
		//call the method
		
		i.sum(2, 3);
		
}
}


example:
````````
package com.capg.jse.lamdaexpressions;

@FunctionalInterface
interface Interf
{
	public int square(int a);
	
}

public class Test1
{
	public static void main(String[] args) {
		Interf i = (a)->a*a;
		
		
		int square = i.square(5);
		System.out.println("square value is: " + square);
		
}
}



example without lambda expression:
``````````````````````````````````
package com.capg.jse.lamdaexpressions;

class MyRunnable implements Runnable
{

	@Override
	public void run() {
		for(int i=0;i<10;i++)
		{
			System.out.println("child thread");
		}
		
	}
	
	
}
public class Test2{
	
	public static void main(String[] args) {
		Runnable r = new MyRunnable();
		Thread t = new Thread(r);
		//call the start method
		
		t.start();
		
		for(int i=0;i<10;i++)
		{
			System.out.println("main thread");
		}
	}

}


with lambda expression:
``````````````````````
package com.capg.jse.lamdaexpressions;

public class Test2{
	
	public static void main(String[] args) {
		
		
		Runnable r = ()->{
			
			for(int i=0;i<10;i++)
			{
				System.out.println("child thread");
			}
			
		};
		
		
		Thread t = new Thread(r);
		t.start();
		
	}

}






default methods:
```````````````
the main advantage of default methods is without effecting implementation
classes we can add new functionality to the interface (backward compatibility).


example:
````````
package com.capg.jse.lamdaexpressions;

interface interf1
{
	default void m1()
	{
		System.out.println("default method");
	}
}
public class Test3 implements interf1
{
    public void m1()
	{
		System.out.println("default method-imp class");
	}
	public static void main(String[] args) {
		
		Test3 t = new Test3();
		t.m1();
		
	}

}


two interfaces can contain default method with same signature then 
there may be a chance of ambiguity problem to the implementation 
class.

To overcome this problem,we should override default method in the 
implementation class otherwise we get compile time error.

example:
````````
package com.capg.jse.lamdaexpressions;

interface Left
{
	default void m1()
	{
		System.out.println("left default method");
	}
}

interface Right
{
	default void m1()
	{
		System.out.println("right default method");
	}
}





public class Test4 implements Left,Right{
	
	public void m1()
	{
		//calling right interface m1()
		Right.super.m1();
		//calling left interface m1()
		Left.super.m1();
	}
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.m1();
	}

}



static methods inside interface:
```````````````````````````````

from 1.8 version onwards in addition to default methods we can 
define static methods also inside interface to define utility functions.

interface static methods by default not available to the implementation clases
hence by using implementation class reference we can't call the interface
static methods.

we should class interface static methods by using interface name.

example:
``````
package com.capg.jse.lamdaexpressions;

interface i1
{
	public static void sum(int a, int b)
	{
		System.out.println("the sum: " + (a+b));
	}
}
public class Test5 implements i1 
{
	public static void main(String[] args) {
		
		
		Test5 obj= new Test5();
		//compile tiem error: obj.sum(4,4);
		
		i1.sum(3, 4);
		
	}

}


note:
from jdk 1.8 version onwards , we can define main() inside interface and
hence we can even run also.

example:
````````
package com.capg.jse.lamdaexpressions;

public interface i2 {
	
	public static void main(String[] args)
	{
		System.out.println("hello");
	}

}





lambda expressions with collections:
````````````````````````````````````


example with out lambda expression:
```````````````````````````````````
package com.capg.jse.lamdaexpressions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

class MyComparator implements Comparator<Integer>
{

	@Override
	public int compare(Integer i1, Integer i2) {
		
		if(i1<i2)
		{
			return 9;
		}
		else if(i1>i2)
		{
			return -9;
		}
		else
		{
			return 0;
		}
		
	}
	
}
public class Test6 {
	
	public static void main(String[] args) {
		
		
		ArrayList<Integer> l = new ArrayList<Integer>();
		l.add(10);
		l.add(0);
		l.add(5);
		l.add(20);
		
		
		System.out.println("before sorting: " + l);
		Collections.sort(l,new MyComparator());
		
		System.out.println("after sorting: " + l);
		
	}

}






example with lambda expression:
````````````````````````````````
package com.capg.jse.lamdaexpressions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;


public class Test6 {
	
	public static void main(String[] args) {
		
		
		ArrayList<Integer> l = new ArrayList<Integer>();
		l.add(10);
		l.add(0);
		l.add(5);
		l.add(20);
		
		
		System.out.println("before sorting: " + l);
		Collections.sort(l,(i1,i2)->(i1<i2)?-1:(i1>i2)?1:0);
		
		System.out.println("after sorting: " + l);
		
	}

}


assignment:
``````````````
do the same kind of program w.r.to TreeSet



example with TreeMap object:
`````````````````````````````
package com.capg.jse.lamdaexpressions;

import java.util.TreeMap;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		TreeMap<Integer,String> m = new TreeMap<Integer,String>((i1,i2)->(i1<i2)?1:(i1>i2)?-1:0);
		
		m.put(100, "bunny");
		m.put(600, "sunny");
		m.put(200, "chinny");
		m.put(700, "vinny");
		m.put(400, "pinny");
		
		System.out.println(m);
	
	}

}


example w.r.to user defined object along with lambda expression:
````````````````````````````````````````````````````````````````
package com.capg.jse.lamdaexpressions;

import java.util.ArrayList;
import java.util.Collections;

public class Test8 {
	
	public static void main(String[] args) {
		
		
		ArrayList<Employee> l = new ArrayList<Employee>();
		
		l.add(new Employee(100,"ram"));
		l.add(new Employee(600,"bunny"));
		l.add(new Employee(200,"deepika"));
		l.add(new Employee(400,"sunny"));
		l.add(new Employee(500,"alia"));
		l.add(new Employee(300,"mallika"));
				
		System.out.println("before sorting");
		System.out.println(l);
		
		Collections.sort(l,(e1,e2)->(e1.empid<e2.empid)?-1:(e1.empid>e2.empid)?1:0);
		
		System.out.println("after sorting: ");
		
		System.out.println(l);
		
	}

}


Employee.java:
````````````````
package com.capg.jse.lamdaexpressions;

public class Employee {
	
	int empid;
	String empnae;
	public Employee(int empid, String empname) {
		super();
		this.empid = empid;
		this.empnae = empnae;
	}
	@Override
	public String toString() {
		return empid + " " + empnae;
	}
	
}





stream api:
```````````

 java.util.stream 
 
 
-it contains some classes, interfaces and enum to allow 
 functional style operations on the elements.
 
 
-Stream is functional in nature.

-stream is lazy because it evaluates code only when required.

-filter,collect,print , convert 


Product.java:
``````````````
package com.stream;

public class Product {

	private int id;
	private String name;
	float price;
	
	
	public Product(int id, String name, float price) {
		super();
		this.id = id;
		this.name = name;
		this.price = price;
	}
	
	
}

Test1.java:
````````````
package com.stream;

import java.util.ArrayList;
import java.util.List;

public class Test1 {

	public static void main(String[] args) {
		
		List<Product> pl = new ArrayList<Product>();
		
		//adding products
		
		pl.add(new Product(1,"hp",34000f));
		pl.add(new Product(2,"lenvo",44000f));
		pl.add(new Product(3,"dell",24000f));
		pl.add(new Product(4,"acer",28000f));
		pl.add(new Product(5,"apple",84000f));
		pl.add(new Product(6,"sony",74000f));
		
		
		List<Float> productPriceList = new ArrayList<Float>();
		for(Product p:pl)
		{
			//filtering data of list
			if(p.price<30000)
			{
				productPriceList.add(p.price);
			}
			
		}
		
		System.out.println(productPriceList);
		
	}
}


example:
````````
package com.stream;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class Test1 {

	public static void main(String[] args) {
		
		List<Product> pl = new ArrayList<Product>();
		
		//adding products
		
		pl.add(new Product(1,"hp",34000f));
		pl.add(new Product(2,"lenvo",24000f));
		pl.add(new Product(3,"dell",34000f));
		pl.add(new Product(4,"acer",28000f));
		pl.add(new Product(5,"apple",84000f));
		pl.add(new Product(6,"sony",74000f));
		
		//1-List<Float> productPriceList = pl.stream().filter(p -> p.price>30000).map(p->p.price).collect(Collectors.toList());
		
		//1-System.out.println(productPriceList);
		
		//2-pl.stream().filter(p->p.price==34000).forEach(p->System.out.println(p.name));
		
		//3-Float totalPrice = pl.stream().map(p->p.price).reduce(0.0f,(sum,price)->sum+price);
	   //3-System.out.println(totalPrice);
		
		//4-Double totalPrice = pl.stream().collect(Collectors.summingDouble(p->p.price));
		//4-System.out.println(totalPrice);
		
		//5-Product product1 = pl.stream().max((p1,p2)->p1.price>p2.price?1:-1).get();
		//5-System.out.println("maximum price: " + product1.price);
		
		//6-Product product2 = pl.stream().min((p1,p2)->p1.price>p2.price?1:-1).get();
		//6-System.out.println("minimum price: " + product2.price);
		
		//7-long count = pl.stream().filter(p->p.price<30000).count();
		//7-System.out.println(count);
		
		 List<Float> productPriceList = pl.stream().filter(p->p.price>30000).map(Product::getPrice).collect(Collectors.toList());
		 System.out.println(productPriceList);
		
	}
}


filter(Predicate p)

Predicate -functioanl interface

   abstract method 
   
   
Predicate:
``````````
A Predicate is a function with a single argument and returns boolean value.

To implement predicate function in java, Oracle people introduced Predicate interface in 
java 1.8 version 

This interface present in java.util.function package.

it is a functional interface and it contains only one method(i.e test())



->write a predicate to check whether the given integer is greater than 10 or not?

public boolean test(Integer i)
 if(i>10){return true;}
 else{return false;}
 
(Integer i) -> {
if(i>10) return true;
else return false;
}

Predicate<Integer> p = i -> (i>10);

sysout(p.test(100));//true
sysout(p.test(9));//false
sysout(p.test(true));//compile time error.

->
Predicate<String> p = s->(s.length()>3);
sysout(p.test("rama"));//true
sysout(p.test("Rk"));//false


Predicate example:
``````````````````
package com.stream;

import java.util.function.Predicate;

public class Test2 {
	
	public static void main(String[] args) {
		
		int[] x= {0,5,10,15,20,25,30};
	 
		Predicate<Integer> p1 = i->i>10;
		
		System.out.println("the numbers greater than 10 are");
		m1(p1,x);
		
		Predicate<Integer> p2 = i->i%2==0;
		
		System.out.println("The even numbers are");
		m1(p2,x);
		
		System.out.println("The numbers not greater than 10 are: ");
		m1(p1.negate(),x);
		
		System.out.println("The numbers greater than 10 and even are: ");
		m1(p1.and(p2),x);
		
		System.out.println("The numbers greater than 10 or even are: ");
		m1(p1.or(p2),x);
	}
	public static void m1(Predicate<Integer> p,int[] x)
	{
		for(int x1:x)
		{
			if(p.test(x1))
				System.out.println(x1);
		}
	}

}


example:
`````````
package com.stream;

import java.util.function.Predicate;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		String[] names= {"anitha","Begum","divya","swapna","Brammaiah","anji"};
		
		Predicate<String> startsWithB = s->s.charAt(0)=='B';
		
		System.out.println("The names starts with B are: ");
		
		for(String s:names)
		{
			if(startsWithB.test(s)) {
				System.out.println(s);
			}
		}
	}

}


assignment:

write a predicate to remove null values and empty strings from the given list.

String[] names={"Rk","null","","Ravi","Anitha","Shiva","null"};





example on user authentication using predicate:

example:
`````````
package com.stream;

import java.util.Scanner;
import java.util.function.Predicate;

public class Test4 {
	
	public static void main(String[] args) {
		
		Predicate<User> p = u->u.username.equals("rk")&&u.pwd.equals("infy");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter User name:");
		String username = sc.next();
		
		System.out.println("Enter password: ");
		String pwd = sc.next();
		
		if(p.test(new User(username,pwd))) {
			System.out.println("valid user and can avail all services");
		}
		else
		{
			System.out.println("invalid user you cannot avail services");
		}
		
		
		
	}

}



Function:
 exactly same as predicate except that functions can return any type of result
 but Predicate can return only boolean value.


 
Predicate<T>
Function<T,R>


example:
`````````
package com.stream;

import java.util.function.Function;

public class Test6 {
	
	public static void main(String[] args) {
		
		String s= "viha  systems private limited hyderabad";
		
		Function<String,Integer> f = s1->s1.length()-s1.replaceAll(" ","").length();
		System.out.println(f.apply(s));
	}

}



assignment:
 progrram to find student grade by using function.
 

function chaining:
``````````````````
we can combine multiple functions together to form  more complex functions.

andThen()
compose()



package com.stream;

import java.util.function.Function;

public class Test7 {
	
	public static void main(String[] args) {
		
		/*
		 * Function<String,String> f1 = s->s.toUpperCase(); Function<String,String> f2 =
		 * s->s.substring(0,9);
		 * 
		 * System.out.println("The Result of f1: " + f1.apply("AishwaryaAbhi"));
		 * System.out.println("The Result of f2: " + f2.apply("AishwaryaAbhi"));
		 * System.out.println("The Result of f1.andThen(f2): " +
		 * f1.andThen(f2).apply("AishwaryaAbhi"));
		 */
		
		Function<Integer,Integer> f1 = i->i+i;
		Function<Integer,Integer> f2 = i->i*i*i;
		
		
		System.out.println(f1.andThen(f2).apply(2));
		System.out.println(f1.compose(f2).apply(2));
		
		Function<String,String> f3 = Function.identity();
		String s2 = f3.apply("rk");
		System.out.println(s2);
		
		
	}

}


Consumer:
````````
Sometimes our requirement is we have to provide some input value,perform certain operation, 
but not required to return anything, then we should go for Consumer.
i.e Consumer can be used to consume object and perform certain operation.


Movie.java:
````````````
package com.stream;

public class Movie {
	
	String name;
	String hero;
	String heroine;
	public Movie(String name, String hero, String heroine) {
		super();
		this.name = name;
		this.hero = hero;
		this.heroine = heroine;
	}
	

}

Test9.java:
```````````
package com.stream;

import java.util.ArrayList;
import java.util.function.Consumer;

public class Test9 {
	
	public static void main(String[] args) {
		
		ArrayList<Movie> l = new ArrayList<Movie>();
		
		populate(l);
		
		Consumer<Movie> c = m->
		{
			
			System.out.println("Movie name: " + m.name);
			System.out.println("Movie Hero: " + m.hero);
			System.out.println("Movie actress: " +m.heroine);
		};
		
		for(Movie m:l)
		{
			c.accept(m);
		}
		
	}
	
	public static void populate(ArrayList<Movie> l)
	{
		l.add(new Movie("Bahubali","Prabhas","Anushka"));
		l.add(new Movie("RRR","NTR","Alia"));
		l.add(new Movie("KGF","Yash","Srinidhi"));
		l.add(new Movie("Pushpa","Arjun","Rashmika"));
		
		
	}

}


example using Predicate,Consumer & Function:
``````````````````````````````````````````````
package com.stream;

import java.util.ArrayList;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

public class Test10 {
	
	public static void main(String[] args) {
		
		ArrayList<Student> l = new ArrayList<Student>();
		populate(l);
		
		Predicate<Student> p = s->s.marks>=60;
		Function<Student,String> f = s->{
			int marks = s.marks;
			if(marks>=80) {
				return "A[Dictiniction]";
			}
			else if(marks>=60) {
				return "B[First Class]";
			}
			else if(marks>=50) {
				return "C[Second Class]";
			}
			else if(marks>=35) {
				return "D[Third Class]";
			}
			else
			{
				return "E[Failed]";
			}
		};
		
		Consumer<Student> c = s->{
			System.out.println("Student Name: " + s.name);
			System.out.println("Student Marks: " + s.marks);
			System.out.println("Student Grade: " + f.apply(s));	
			System.out.println();
		};
		
		for(Student s: l)
		{
			 if(p.test(s)) {
				 c.accept(s);
			 }
		}
	}
	
	public static void populate(ArrayList<Student> l)
	{
		l.add(new Student("Sunny",100));
		l.add(new Student("Bunny",65));
		l.add(new Student("Chinny",55));
		l.add(new Student("Vinny",45));
		l.add(new Student("Pinny",25));
	}

}


assignment:
```````````
refer  Supplier -functional interface and do some programs?


Properties class :
 this object contains key and value pair. both as a stirng.
 
java.util.Properties is the subclass of Hashtable



it can be used to get property value based on property key.


  abc.properties(src/main/resources)->classpath
  
  
  name="rama"
  officename="Apple"
  


load(Reader)
load(InputStream)
loadFromXML(InputStream)
getProperty(String key, String defaultvalue);
setProperty(k,v)
public void list(PrintStream out)



	example:

package com.properties_loggers;

import java.io.FileReader;
import java.util.Properties;

public class Test1 {
	
	
	public static void main(String[] args) throws Exception {
		
		
		FileReader reader = new FileReader("E:\\infosys_training_13thSept_2022\\java11 beyond basics\\src\\com\\properties_loggers\\db.properties");
		Properties p = new Properties();
		p.load(reader);
		
		System.out.println(p.getProperty("user"));
		System.out.println(p.getProperty("password"));
	}

}


db.properties:
``````````````
user=system
password=tcs


example:
````````
package com.properties_loggers;

import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

public class Test2 {

	
	public static void main(String[] args)throws Exception {
		
		Properties p = System.getProperties();
		Set set = p.entrySet();
		
		Iterator itr = set.iterator();
		
		while(itr.hasNext())
		{
			Map.Entry entry = (Map.Entry)itr.next();
			
			System.out.println(entry.getKey() + " " + entry.getValue());
		}
	}
}


	
 
what is unittesting and why?
````````````````````````````
unit testing is a type of software testing where individual units or
components of a software are tested.

The purpose is to validate that each unit of the software code
performs as expected.

unit testing is done during the development of an application 
by the developers.

unit tests isolate a section of code and verify it's correctness.

A unit may be an individual function , method, procedure, modulename
or object.


what is junit?
```````````````
->junit is a free and open source unit testing framework for java applications.

->junit was developed by kent back and erich gamma.

->it's first version was released in 1997

->it became one of the most popular testing frameorks in the java 
  community due to its ease of use.
  
->it is a lightweight testing framework which allowed java developers to 
  write unit test cases in java language.
  
->the current version of junit is 5.


 junit -> jar file -> 
  
  
package com.capg.jse.junit;

public class Calculator {
	
	//business logic method 1
	public int add(int x, int y)
	{
		return x+y;
	}
	//business logic method 2
	public int mul(int x, int y)
	{
		return x*y;
	}

}

CalculatorTest.java:
`````````````````````
package com.capg.jse.junit;

import static org.junit.Assert.*;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

public class CalculatorTest {

	
	private static Calculator obj = null;
	
	@BeforeClass
	public static void init()
	{
		obj=new Calculator();
	}
	
	@AfterClass
	public static void destroy()
	{
		obj=null;
	}
	@Test
    public void testAdd()
    {
    	
    	int actualResult = obj.add(10,20);
    	int expectedResult = 30;
    	assertEquals(expectedResult, actualResult);
    }
	
	
	@Test
	public void testMul()
	{
		
		
		int actualResult = obj.mul(10,20);
		int expectedResult = 2000;
		assertEquals(expectedResult, actualResult);
		
	}
	
	
}


junit5 architecture:
````````````````````

Junit 5 Architecture mainly divide in three modules:

JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage


junit annotations:
```````````````````
@Test-to mark a method as test case method
@BeforeEach-before executing each and every test case method
@AfterEach-after executing each and every test case method
@BeforeAll-5 test case -1's
@AfterAll-1 time 
@ParameterizedTest

@ValueSource
@CsvFileSource
@Disabled

....

junit Assertions:
```````````````````
to refer junit5 api official documentation use the below url

https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html

->junit5 asseertions help us in validating the expected output with 
  the actual output of a test case.
  
->in short, assertions are nothing but static methods that we call in our 
  tests to verify expected behaviour.

->All Junit jupiter assertions are present in the 
  org.junit.jupiter.api.Assertions class
  
  
 Junit Assertion Methods:
 `````````````````````````
 assertEquals and assertNotEquals
 assertTrue and assertFalse
 assertNull and assertNotNull
 assertSame and assertNotSame
 assertThrows
 
 ....
 
example:
````````
package com.capg.jse.junit;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class CalculatorTest2 {

	@BeforeEach
	public void beforeEach() {
		System.out.println("before each method executed");
	}

	@AfterEach
	public void afterEach() {
		System.out.println("after each method executed");
	}

	@Test
	@DisplayName("testing test1 method")
	public void test1() {
		System.out.println("iam test1 method executed");
	}

	@Test
	@Disabled
	public void test2() {
		System.out.println("iam test2 method executed");
	}
	@BeforeAll
	public static void beforeAll()
	{
		System.out.println("iam executed before but only once");
	}
	@AfterAll
	public static void afterAll()
	{
		System.out.println("iam executed after all test but only once");
	}
}


example on @ParameterizedTest and @ValueSource:
````````````````````````````````````````````````
package com.capg.jse.junit;


public class PalindromeCheck{

	  public boolean isPalindrome(String str){
	  
	   String reverse="";
	   int length = str.length();
	   for(int i=length-1;i>=0;i--)
	   {
	       reverse = reverse+str.charAt(i);
		   }
		   if(str.equals(reverse)){
		   return true;
		   }
		   else{
		   return false;
		   }
		   
	  }
	}   
	
	
TestPalindromeCheck.java:
``````````````````````````
package com.capg.jse.junit;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class TestPalindromeCheck {

	@ParameterizedTest
	@ValueSource(strings = {"racecar","radar","madam","malayalam","liril","rajini"})
	public void testIsPalindrome(String str)
	{
		PalindromeCheck obj = new PalindromeCheck();
		boolean actual = obj.isPalindrome(str);
		assertTrue(actual);
	}

}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	 
	 
	 
	 